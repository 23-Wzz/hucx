<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>UCX: UCP Communication routines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="UCX_Logo_80x80.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UCX
   &#160;<span id="projectnumber">1.5</span>
   </div>
   <div id="projectbrief">Unified Communication X</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Programming&#160;Interface</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___u_c_p___c_o_m_m.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UCP Communication routines<div class="ingroups"><a class="el" href="group___u_c_p___a_p_i.html">Unified Communication Protocol (UCP) API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structucp__err__handler"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#structucp__err__handler">ucp_err_handler</a></td></tr>
<tr class="memdesc:structucp__err__handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP endpoint error handling context.  <a href="group___u_c_p___c_o_m_m.html#structucp__err__handler">More...</a><br /></td></tr>
<tr class="separator:structucp__err__handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga55df42689ef1f5621eae4d1ffb16856e"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a></td></tr>
<tr class="memdesc:ga55df42689ef1f5621eae4d1ffb16856e"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP Tag Identifier.  <a href="#ga55df42689ef1f5621eae4d1ffb16856e">More...</a><br /></td></tr>
<tr class="separator:ga55df42689ef1f5621eae4d1ffb16856e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a8b5741a4e66d7e890d31ef7cbf88ec"><td class="memItemLeft" align="right" valign="top">typedef struct ucp_recv_desc *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a></td></tr>
<tr class="memdesc:ga6a8b5741a4e66d7e890d31ef7cbf88ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP Message descriptor.  <a href="#ga6a8b5741a4e66d7e890d31ef7cbf88ec">More...</a><br /></td></tr>
<tr class="separator:ga6a8b5741a4e66d7e890d31ef7cbf88ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae461587956dd56a6bc7d67b027845891"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a></td></tr>
<tr class="memdesc:gae461587956dd56a6bc7d67b027845891"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP Datatype Identifier.  <a href="#gae461587956dd56a6bc7d67b027845891">More...</a><br /></td></tr>
<tr class="separator:gae461587956dd56a6bc7d67b027845891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad905bbbff95166a1e9b0e9743feb677"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status)</td></tr>
<tr class="memdesc:gaad905bbbff95166a1e9b0e9743feb677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback for non-blocking sends.  <a href="#gaad905bbbff95166a1e9b0e9743feb677">More...</a><br /></td></tr>
<tr class="separator:gaad905bbbff95166a1e9b0e9743feb677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2174ce2b86eb56f6bd4bd62865e87f1"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaf2174ce2b86eb56f6bd4bd62865e87f1">ucp_err_handler_cb_t</a>) (void *arg, <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status)</td></tr>
<tr class="memdesc:gaf2174ce2b86eb56f6bd4bd62865e87f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to process peer failure.  <a href="#gaf2174ce2b86eb56f6bd4bd62865e87f1">More...</a><br /></td></tr>
<tr class="separator:gaf2174ce2b86eb56f6bd4bd62865e87f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga487a20aada512b312bc21757e368120d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group___u_c_p___c_o_m_m.html#structucp__err__handler">ucp_err_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga487a20aada512b312bc21757e368120d">ucp_err_handler_t</a></td></tr>
<tr class="memdesc:ga487a20aada512b312bc21757e368120d"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP endpoint error handling context.  <a href="#ga487a20aada512b312bc21757e368120d">More...</a><br /></td></tr>
<tr class="separator:ga487a20aada512b312bc21757e368120d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a6234b8497006e26ba02f10ddc0bbf5"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a6234b8497006e26ba02f10ddc0bbf5">ucp_stream_recv_callback_t</a>) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, size_t length)</td></tr>
<tr class="memdesc:ga6a6234b8497006e26ba02f10ddc0bbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback for non-blocking stream oriented receives.  <a href="#ga6a6234b8497006e26ba02f10ddc0bbf5">More...</a><br /></td></tr>
<tr class="separator:ga6a6234b8497006e26ba02f10ddc0bbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00ac0fe5665d15fab5cd254af9b07758"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga00ac0fe5665d15fab5cd254af9b07758">ucp_tag_recv_callback_t</a>) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *info)</td></tr>
<tr class="memdesc:ga00ac0fe5665d15fab5cd254af9b07758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completion callback for non-blocking tag receives.  <a href="#ga00ac0fe5665d15fab5cd254af9b07758">More...</a><br /></td></tr>
<tr class="separator:ga00ac0fe5665d15fab5cd254af9b07758"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac5d94ea07dc4feae2708e67378ba2ad0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gac5d94ea07dc4feae2708e67378ba2ad0">ucp_atomic_post_op_t</a> { <br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#ggac5d94ea07dc4feae2708e67378ba2ad0ac9bbe0e18afb3ffc3f308feb0a2343c0">UCP_ATOMIC_POST_OP_ADD</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggac5d94ea07dc4feae2708e67378ba2ad0a429b49ede714d04c4675a6e3966964e4">UCP_ATOMIC_POST_OP_AND</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggac5d94ea07dc4feae2708e67378ba2ad0afddd2f7287b622caf220503a6ae38460">UCP_ATOMIC_POST_OP_OR</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggac5d94ea07dc4feae2708e67378ba2ad0ac498a55f8365e9a0821187367bc2cf89">UCP_ATOMIC_POST_OP_XOR</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#ggac5d94ea07dc4feae2708e67378ba2ad0a97ee6dd65f14dc12791831435329c38d">UCP_ATOMIC_POST_OP_LAST</a>
<br />
 }<tr class="memdesc:gac5d94ea07dc4feae2708e67378ba2ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic operation requested for ucp_atomic_post.  <a href="group___u_c_p___c_o_m_m.html#gac5d94ea07dc4feae2708e67378ba2ad0">More...</a><br /></td></tr>
<tr class="separator:gac5d94ea07dc4feae2708e67378ba2ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:gabd91e0300a53e38d28dbb53dfbb66c55"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gabd91e0300a53e38d28dbb53dfbb66c55">ucp_atomic_fetch_op_t</a> { <br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55ae7540b3c7046a454f750f816bdfa1037">UCP_ATOMIC_FETCH_OP_FADD</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55ad5a1d6d5e5cb563b477258a4656c9069">UCP_ATOMIC_FETCH_OP_SWAP</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55adc79d547543b1803dace41a6bdea043c">UCP_ATOMIC_FETCH_OP_CSWAP</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55a072b82e2e35a90b7ed3e113423e6d5e3">UCP_ATOMIC_FETCH_OP_FAND</a>, 
<br />
&#160;&#160;<a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55a2b0b3779905ea67eea996ae8e296ed59">UCP_ATOMIC_FETCH_OP_FOR</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55a86930c2cddc0a884cbf88ced6c330049">UCP_ATOMIC_FETCH_OP_FXOR</a>, 
<a class="el" href="group___u_c_p___c_o_m_m.html#ggabd91e0300a53e38d28dbb53dfbb66c55a2532883ac97f4ee8178b52318f978a05">UCP_ATOMIC_FETCH_OP_LAST</a>
<br />
 }<tr class="memdesc:gabd91e0300a53e38d28dbb53dfbb66c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic operation requested for ucp_atomic_fetch.  <a href="group___u_c_p___c_o_m_m.html#gabd91e0300a53e38d28dbb53dfbb66c55">More...</a><br /></td></tr>
<tr class="separator:gabd91e0300a53e38d28dbb53dfbb66c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:gab471a9c7ab815e3d3ad7af80253f5cc2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gab471a9c7ab815e3d3ad7af80253f5cc2">ucp_stream_recv_flags_t</a> { <a class="el" href="group___u_c_p___c_o_m_m.html#ggab471a9c7ab815e3d3ad7af80253f5cc2a5fb4ed4f8009d969ea9a8b3f3542424c">UCP_STREAM_RECV_FLAG_WAITALL</a> = UCS_BIT(0)
 }<tr class="memdesc:gab471a9c7ab815e3d3ad7af80253f5cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to define behavior of <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a> function.  <a href="group___u_c_p___c_o_m_m.html#gab471a9c7ab815e3d3ad7af80253f5cc2">More...</a><br /></td></tr>
<tr class="separator:gab471a9c7ab815e3d3ad7af80253f5cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9022ff0ebb56cac81f6ba81bb28f71b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga9022ff0ebb56cac81f6ba81bb28f71b3">ucp_stream_send_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb, unsigned flags)</td></tr>
<tr class="memdesc:ga9022ff0ebb56cac81f6ba81bb28f71b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking stream send operation.  <a href="#ga9022ff0ebb56cac81f6ba81bb28f71b3">More...</a><br /></td></tr>
<tr class="separator:ga9022ff0ebb56cac81f6ba81bb28f71b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7343bd638924e5518041311d5c1dfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaae7343bd638924e5518041311d5c1dfc">ucp_tag_send_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb)</td></tr>
<tr class="memdesc:gaae7343bd638924e5518041311d5c1dfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking tagged-send operations.  <a href="#gaae7343bd638924e5518041311d5c1dfc">More...</a><br /></td></tr>
<tr class="separator:gaae7343bd638924e5518041311d5c1dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad90aa964e14fef59b4e3bd9120cca669"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gad90aa964e14fef59b4e3bd9120cca669">ucp_tag_send_nbr</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, void *req)</td></tr>
<tr class="memdesc:gad90aa964e14fef59b4e3bd9120cca669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking tagged-send operations with user provided request.  <a href="#gad90aa964e14fef59b4e3bd9120cca669">More...</a><br /></td></tr>
<tr class="separator:gad90aa964e14fef59b4e3bd9120cca669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd3e1ccae2ef34463e8313d09d3db17f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gabd3e1ccae2ef34463e8313d09d3db17f">ucp_tag_send_sync_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb)</td></tr>
<tr class="memdesc:gabd3e1ccae2ef34463e8313d09d3db17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking synchronous tagged-send operation.  <a href="#gabd3e1ccae2ef34463e8313d09d3db17f">More...</a><br /></td></tr>
<tr class="separator:gabd3e1ccae2ef34463e8313d09d3db17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf3b4504a329a46d2d4ec0a8cec08130"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga6a6234b8497006e26ba02f10ddc0bbf5">ucp_stream_recv_callback_t</a> cb, size_t *length, unsigned flags)</td></tr>
<tr class="memdesc:gadf3b4504a329a46d2d4ec0a8cec08130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking stream receive operation of structured data into a user-supplied buffer.  <a href="#gadf3b4504a329a46d2d4ec0a8cec08130">More...</a><br /></td></tr>
<tr class="separator:gadf3b4504a329a46d2d4ec0a8cec08130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47f307f4765eb5410f24ac27986b59d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga47f307f4765eb5410f24ac27986b59d7">ucp_stream_recv_data_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, size_t *length)</td></tr>
<tr class="memdesc:ga47f307f4765eb5410f24ac27986b59d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking stream receive operation of unstructured data into a UCP-supplied buffer.  <a href="#ga47f307f4765eb5410f24ac27986b59d7">More...</a><br /></td></tr>
<tr class="separator:ga47f307f4765eb5410f24ac27986b59d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb24cdfc33dfb2886551b51843aa6304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaeb24cdfc33dfb2886551b51843aa6304">ucp_tag_recv_nb</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag_mask, <a class="el" href="group___u_c_p___c_o_m_m.html#ga00ac0fe5665d15fab5cd254af9b07758">ucp_tag_recv_callback_t</a> cb)</td></tr>
<tr class="memdesc:gaeb24cdfc33dfb2886551b51843aa6304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking tagged-receive operation.  <a href="#gaeb24cdfc33dfb2886551b51843aa6304">More...</a><br /></td></tr>
<tr class="separator:gaeb24cdfc33dfb2886551b51843aa6304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a86663a4a144fd81d7a4e3378c5edd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga5a86663a4a144fd81d7a4e3378c5edd2">ucp_tag_recv_nbr</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag_mask, void *req)</td></tr>
<tr class="memdesc:ga5a86663a4a144fd81d7a4e3378c5edd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking tagged-receive operation.  <a href="#ga5a86663a4a144fd81d7a4e3378c5edd2">More...</a><br /></td></tr>
<tr class="separator:ga5a86663a4a144fd81d7a4e3378c5edd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41668f468dc37a7634116b8210815f22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga41668f468dc37a7634116b8210815f22">ucp_tag_probe_nb</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag, <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a> tag_mask, int remove, <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *info)</td></tr>
<tr class="memdesc:ga41668f468dc37a7634116b8210815f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking probe and return a message.  <a href="#ga41668f468dc37a7634116b8210815f22">More...</a><br /></td></tr>
<tr class="separator:ga41668f468dc37a7634116b8210815f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac335b3ae4c9577728d9c0f2ecd44c084"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gac335b3ae4c9577728d9c0f2ecd44c084">ucp_tag_msg_recv_nb</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *buffer, size_t count, <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a> datatype, <a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a> message, <a class="el" href="group___u_c_p___c_o_m_m.html#ga00ac0fe5665d15fab5cd254af9b07758">ucp_tag_recv_callback_t</a> cb)</td></tr>
<tr class="memdesc:gac335b3ae4c9577728d9c0f2ecd44c084"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking receive operation for a probed message.  <a href="#gac335b3ae4c9577728d9c0f2ecd44c084">More...</a><br /></td></tr>
<tr class="separator:gac335b3ae4c9577728d9c0f2ecd44c084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f3d5def7a77c4ba88f9e1eefa4b7e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga77f3d5def7a77c4ba88f9e1eefa4b7e6">ucp_put_nbi</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t length, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:ga77f3d5def7a77c4ba88f9e1eefa4b7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking implicit remote memory put operation.  <a href="#ga77f3d5def7a77c4ba88f9e1eefa4b7e6">More...</a><br /></td></tr>
<tr class="separator:ga77f3d5def7a77c4ba88f9e1eefa4b7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ba986b2bde69c215abd5766dbceeb18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga1ba986b2bde69c215abd5766dbceeb18">ucp_put_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t length, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb)</td></tr>
<tr class="memdesc:ga1ba986b2bde69c215abd5766dbceeb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking remote memory put operation.  <a href="#ga1ba986b2bde69c215abd5766dbceeb18">More...</a><br /></td></tr>
<tr class="separator:ga1ba986b2bde69c215abd5766dbceeb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3597f699227d598651f6630fbd7968b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gae3597f699227d598651f6630fbd7968b">ucp_get_nbi</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *buffer, size_t length, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:gae3597f699227d598651f6630fbd7968b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking implicit remote memory get operation.  <a href="#gae3597f699227d598651f6630fbd7968b">More...</a><br /></td></tr>
<tr class="separator:gae3597f699227d598651f6630fbd7968b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cb68811f53a69d37fd16e8ddb46e23b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga7cb68811f53a69d37fd16e8ddb46e23b">ucp_get_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *buffer, size_t length, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb)</td></tr>
<tr class="memdesc:ga7cb68811f53a69d37fd16e8ddb46e23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking remote memory get operation.  <a href="#ga7cb68811f53a69d37fd16e8ddb46e23b">More...</a><br /></td></tr>
<tr class="separator:ga7cb68811f53a69d37fd16e8ddb46e23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga839312fb4de5e786daacb4fa071d61df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga839312fb4de5e786daacb4fa071d61df">ucp_atomic_post</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, <a class="el" href="group___u_c_p___c_o_m_m.html#gac5d94ea07dc4feae2708e67378ba2ad0">ucp_atomic_post_op_t</a> opcode, uint64_t value, size_t op_size, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:ga839312fb4de5e786daacb4fa071d61df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post an atomic memory operation.  <a href="#ga839312fb4de5e786daacb4fa071d61df">More...</a><br /></td></tr>
<tr class="separator:ga839312fb4de5e786daacb4fa071d61df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43a1a4a517797eb8c5c96ac8841437de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, <a class="el" href="group___u_c_p___c_o_m_m.html#gabd91e0300a53e38d28dbb53dfbb66c55">ucp_atomic_fetch_op_t</a> opcode, uint64_t value, void *result, size_t op_size, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb)</td></tr>
<tr class="memdesc:ga43a1a4a517797eb8c5c96ac8841437de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post an atomic fetch operation.  <a href="#ga43a1a4a517797eb8c5c96ac8841437de">More...</a><br /></td></tr>
<tr class="separator:ga43a1a4a517797eb8c5c96ac8841437de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae082ad7af428645ebe6e469d3d06a757"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gae082ad7af428645ebe6e469d3d06a757">ucp_request_check_status</a> (void *request)</td></tr>
<tr class="memdesc:gae082ad7af428645ebe6e469d3d06a757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the status of non-blocking request.  <a href="#gae082ad7af428645ebe6e469d3d06a757">More...</a><br /></td></tr>
<tr class="separator:gae082ad7af428645ebe6e469d3d06a757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga707cbbef8cdcf90fa7cf63c922ef2c7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga707cbbef8cdcf90fa7cf63c922ef2c7f">ucp_tag_recv_request_test</a> (void *request, <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *info)</td></tr>
<tr class="memdesc:ga707cbbef8cdcf90fa7cf63c922ef2c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the status and currently available state of non-blocking request returned from <a class="el" href="group___u_c_p___c_o_m_m.html#gaeb24cdfc33dfb2886551b51843aa6304">ucp_tag_recv_nb</a> routine.  <a href="#ga707cbbef8cdcf90fa7cf63c922ef2c7f">More...</a><br /></td></tr>
<tr class="separator:ga707cbbef8cdcf90fa7cf63c922ef2c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d8d8823b24cb25dcab8bf44c72fa25e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga4d8d8823b24cb25dcab8bf44c72fa25e">ucp_stream_recv_request_test</a> (void *request, size_t *length_p)</td></tr>
<tr class="memdesc:ga4d8d8823b24cb25dcab8bf44c72fa25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the status and currently available state of non-blocking request returned from <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a> routine.  <a href="#ga4d8d8823b24cb25dcab8bf44c72fa25e">More...</a><br /></td></tr>
<tr class="separator:ga4d8d8823b24cb25dcab8bf44c72fa25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3553f89a61d6b40af4633a2e7c84fc1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga3553f89a61d6b40af4633a2e7c84fc1d">ucp_request_cancel</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, void *request)</td></tr>
<tr class="memdesc:ga3553f89a61d6b40af4633a2e7c84fc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel an outstanding communications request.  <a href="#ga3553f89a61d6b40af4633a2e7c84fc1d">More...</a><br /></td></tr>
<tr class="separator:ga3553f89a61d6b40af4633a2e7c84fc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d1c1c1b2caf4f26c9872e1d708d5f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga1d1c1c1b2caf4f26c9872e1d708d5f68">ucp_stream_data_release</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *data)</td></tr>
<tr class="memdesc:ga1d1c1c1b2caf4f26c9872e1d708d5f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release UCP data buffer returned by <a class="el" href="group___u_c_p___c_o_m_m.html#ga47f307f4765eb5410f24ac27986b59d7">ucp_stream_recv_data_nb</a>.  <a href="#ga1d1c1c1b2caf4f26c9872e1d708d5f68">More...</a><br /></td></tr>
<tr class="separator:ga1d1c1c1b2caf4f26c9872e1d708d5f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e8e46f5953d464382b21edef3ec9994"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free</a> (void *request)</td></tr>
<tr class="memdesc:ga0e8e46f5953d464382b21edef3ec9994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a communications request.  <a href="#ga0e8e46f5953d464382b21edef3ec9994">More...</a><br /></td></tr>
<tr class="separator:ga0e8e46f5953d464382b21edef3ec9994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga432e478b97575b21855074a45d54520d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga432e478b97575b21855074a45d54520d">ucp_request_is_completed</a> (void *request)</td></tr>
<tr class="separator:ga432e478b97575b21855074a45d54520d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85b0a27cf8a3239decabad6a9104eb31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31">ucp_put</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, const void *buffer, size_t length, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:ga85b0a27cf8a3239decabad6a9104eb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking remote memory put operation.  <a href="#ga85b0a27cf8a3239decabad6a9104eb31">More...</a><br /></td></tr>
<tr class="separator:ga85b0a27cf8a3239decabad6a9104eb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4a465cff6c1691106430564899f6f3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaf4a465cff6c1691106430564899f6f3e">ucp_get</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *buffer, size_t length, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:gaf4a465cff6c1691106430564899f6f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking remote memory get operation.  <a href="#gaf4a465cff6c1691106430564899f6f3e">More...</a><br /></td></tr>
<tr class="separator:gaf4a465cff6c1691106430564899f6f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa042d7e76314e1d7ea9717d4adacde7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaa042d7e76314e1d7ea9717d4adacde7b">ucp_atomic_add32</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint32_t add, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:gaa042d7e76314e1d7ea9717d4adacde7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic add operation for 32 bit integers.  <a href="#gaa042d7e76314e1d7ea9717d4adacde7b">More...</a><br /></td></tr>
<tr class="separator:gaa042d7e76314e1d7ea9717d4adacde7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80cd3f104b920c0c2f6bf7cff50fc15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaa80cd3f104b920c0c2f6bf7cff50fc15">ucp_atomic_add64</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint64_t add, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey)</td></tr>
<tr class="memdesc:gaa80cd3f104b920c0c2f6bf7cff50fc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic add operation for 64 bit integers.  <a href="#gaa80cd3f104b920c0c2f6bf7cff50fc15">More...</a><br /></td></tr>
<tr class="separator:gaa80cd3f104b920c0c2f6bf7cff50fc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c777d7d1c59e01151ef5e3fcd7e5b94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga0c777d7d1c59e01151ef5e3fcd7e5b94">ucp_atomic_fadd32</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint32_t add, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint32_t *result)</td></tr>
<tr class="memdesc:ga0c777d7d1c59e01151ef5e3fcd7e5b94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic fetch and add operation for 32 bit integers.  <a href="#ga0c777d7d1c59e01151ef5e3fcd7e5b94">More...</a><br /></td></tr>
<tr class="separator:ga0c777d7d1c59e01151ef5e3fcd7e5b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7435bc5d5e2c4fb6b491d457ab65596b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga7435bc5d5e2c4fb6b491d457ab65596b">ucp_atomic_fadd64</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint64_t add, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint64_t *result)</td></tr>
<tr class="memdesc:ga7435bc5d5e2c4fb6b491d457ab65596b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic fetch and add operation for 64 bit integers.  <a href="#ga7435bc5d5e2c4fb6b491d457ab65596b">More...</a><br /></td></tr>
<tr class="separator:ga7435bc5d5e2c4fb6b491d457ab65596b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43118f9d5e6d8fdfa518887218468bb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga43118f9d5e6d8fdfa518887218468bb3">ucp_atomic_swap32</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint32_t swap, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint32_t *result)</td></tr>
<tr class="memdesc:ga43118f9d5e6d8fdfa518887218468bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic swap operation for 32 bit values.  <a href="#ga43118f9d5e6d8fdfa518887218468bb3">More...</a><br /></td></tr>
<tr class="separator:ga43118f9d5e6d8fdfa518887218468bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2913e345505195a183ccc2583fb4ebc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gaa2913e345505195a183ccc2583fb4ebc">ucp_atomic_swap64</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint64_t swap, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint64_t *result)</td></tr>
<tr class="memdesc:gaa2913e345505195a183ccc2583fb4ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic swap operation for 64 bit values.  <a href="#gaa2913e345505195a183ccc2583fb4ebc">More...</a><br /></td></tr>
<tr class="separator:gaa2913e345505195a183ccc2583fb4ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6078dddaa93c8dfdab3c18014064f0c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6078dddaa93c8dfdab3c18014064f0c0">ucp_atomic_cswap32</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint32_t compare, uint32_t swap, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint32_t *result)</td></tr>
<tr class="memdesc:ga6078dddaa93c8dfdab3c18014064f0c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic conditional swap (cswap) operation for 32 bit values.  <a href="#ga6078dddaa93c8dfdab3c18014064f0c0">More...</a><br /></td></tr>
<tr class="separator:ga6078dddaa93c8dfdab3c18014064f0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa365c16d4c2b4fd2aba6e94fec2c92b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___c_o_m_m.html#gafa365c16d4c2b4fd2aba6e94fec2c92b">ucp_atomic_cswap64</a> (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, uint64_t compare, uint64_t swap, uint64_t remote_addr, <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a> rkey, uint64_t *result)</td></tr>
<tr class="memdesc:gafa365c16d4c2b4fd2aba6e94fec2c92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking atomic conditional swap (cswap) operation for 64 bit values.  <a href="#gafa365c16d4c2b4fd2aba6e94fec2c92b">More...</a><br /></td></tr>
<tr class="separator:gafa365c16d4c2b4fd2aba6e94fec2c92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>UCP Communication routines </p>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structucp__err__handler" id="structucp__err__handler"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ucp_err_handler</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure should be initialized in <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga359c847069dca9ab0d1a026dc3f5f8cd">ucp_ep_params_t</a> to handle peer failure </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a0bf3f446a1821a62dd3a300584792e33"></a><a class="el" href="group___u_c_p___c_o_m_m.html#gaf2174ce2b86eb56f6bd4bd62865e87f1">ucp_err_handler_cb_t</a></td>
<td class="fieldname">
cb</td>
<td class="fielddoc">
<p>Error handler callback, if NULL, will not be called. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a7e49e1843e1adab5561e5fc2b2e1afb1"></a>void *</td>
<td class="fieldname">
arg</td>
<td class="fielddoc">
<p>User defined argument associated with an endpoint, it will be overridden by <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#adaf49e16ee05400f715f432e442336cb">ucp_ep_params_t::user_data</a> if both are set. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga55df42689ef1f5621eae4d1ffb16856e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t <a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UCP tag identifier is a 64bit object used for message identification. UCP tag send and receive operations use the object for an implementation tag matching semantics (derivative of MPI tag matching semantics). </p>

</div>
</div>
<a class="anchor" id="ga6a8b5741a4e66d7e890d31ef7cbf88ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ucp_recv_desc* <a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UCP Message descriptor is an opaque handle for a message returned by <a class="el" href="group___u_c_p___c_o_m_m.html#ga41668f468dc37a7634116b8210815f22">ucp_tag_probe_nb</a>. This handle can be passed to <a class="el" href="group___u_c_p___c_o_m_m.html#gac335b3ae4c9577728d9c0f2ecd44c084">ucp_tag_msg_recv_nb</a> in order to receive the message data to a specific buffer. </p>

</div>
</div>
<a class="anchor" id="gae461587956dd56a6bc7d67b027845891"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t <a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UCP datatype identifier is a 64bit object used for datatype identification. Predefined UCP identifiers are defined by <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga50b3b4e641a197264e963d91be480b6c">ucp_dt_type</a>. </p>

</div>
</div>
<a class="anchor" id="gaad905bbbff95166a1e9b0e9743feb677"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_send_callback_t) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked whenever the <a class="el" href="group___u_c_p___c_o_m_m.html#gaae7343bd638924e5518041311d5c1dfc">send operation</a> is completed. It is important to note that the call-back is only invoked in a case when the operation cannot be completed in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The completed send request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Completion status. If the send operation was completed successfully UCX_OK is returned. If send operation was canceled UCS_ERR_CANCELED is returned. Otherwise, an <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a> is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf2174ce2b86eb56f6bd4bd62865e87f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_err_handler_cb_t) (void *arg, <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked when transport level error detected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>User argument to be passed to the callback. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint to handle transport level error. Upon return from the callback, this <em>ep</em> is no longer usable and all subsequent operations on this <em>ep</em> will fail with the error code passed in <em>status</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga487a20aada512b312bc21757e368120d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___u_c_p___c_o_m_m.html#structucp__err__handler">ucp_err_handler</a>  <a class="el" href="group___u_c_p___c_o_m_m.html#ga487a20aada512b312bc21757e368120d">ucp_err_handler_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure should be initialized in <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga359c847069dca9ab0d1a026dc3f5f8cd">ucp_ep_params_t</a> to handle peer failure </p>

</div>
</div>
<a class="anchor" id="ga6a6234b8497006e26ba02f10ddc0bbf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_stream_recv_callback_t) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, size_t length)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked whenever the <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">receive operation</a> is completed and the data is ready in the receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The completed receive request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Completion status. If the send operation was completed successfully UCX_OK is returned. Otherwise, an <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a> is returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The size of the received data in bytes, always boundary of base datatype size. The value is valid only if the status is UCS_OK. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga00ac0fe5665d15fab5cd254af9b07758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_tag_recv_callback_t) (void *request, <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> status, <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *info)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked whenever the <a class="el" href="group___u_c_p___c_o_m_m.html#gaeb24cdfc33dfb2886551b51843aa6304">receive operation</a> is completed and the data is ready in the receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The completed receive request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">status</td><td>Completion status. If the send operation was completed successfully UCX_OK is returned. If send operation was canceled UCS_ERR_CANCELED is returned. If the data can not fit into the receive buffer the <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558aef3defd5d754266db882e079fad7c544">UCS_ERR_MESSAGE_TRUNCATED</a> error code is returned. Otherwise, an <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">error status</a> is returned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td><a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">Completion information</a> The <em>info</em> descriptor is Valid only if the status is UCS_OK. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gac5d94ea07dc4feae2708e67378ba2ad0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___c_o_m_m.html#gac5d94ea07dc4feae2708e67378ba2ad0">ucp_atomic_post_op_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enumeration defines which atomic memory operation should be performed by the ucp_atomic_post family of fuctions. All of these are non-fetching atomics and will not result in a request handle. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggac5d94ea07dc4feae2708e67378ba2ad0ac9bbe0e18afb3ffc3f308feb0a2343c0"></a>UCP_ATOMIC_POST_OP_ADD&#160;</td><td class="fielddoc">
<p>Atomic add </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac5d94ea07dc4feae2708e67378ba2ad0a429b49ede714d04c4675a6e3966964e4"></a>UCP_ATOMIC_POST_OP_AND&#160;</td><td class="fielddoc">
<p>Atomic and </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac5d94ea07dc4feae2708e67378ba2ad0afddd2f7287b622caf220503a6ae38460"></a>UCP_ATOMIC_POST_OP_OR&#160;</td><td class="fielddoc">
<p>Atomic or </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac5d94ea07dc4feae2708e67378ba2ad0ac498a55f8365e9a0821187367bc2cf89"></a>UCP_ATOMIC_POST_OP_XOR&#160;</td><td class="fielddoc">
<p>Atomic xor </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggac5d94ea07dc4feae2708e67378ba2ad0a97ee6dd65f14dc12791831435329c38d"></a>UCP_ATOMIC_POST_OP_LAST&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gabd91e0300a53e38d28dbb53dfbb66c55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___c_o_m_m.html#gabd91e0300a53e38d28dbb53dfbb66c55">ucp_atomic_fetch_op_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enumeration defines which atomic memory operation should be performed by the ucp_atomic_fetch family of functions. All of these functions will fetch data from the remote node. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggabd91e0300a53e38d28dbb53dfbb66c55ae7540b3c7046a454f750f816bdfa1037"></a>UCP_ATOMIC_FETCH_OP_FADD&#160;</td><td class="fielddoc">
<p>Atomic Fetch and add </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabd91e0300a53e38d28dbb53dfbb66c55ad5a1d6d5e5cb563b477258a4656c9069"></a>UCP_ATOMIC_FETCH_OP_SWAP&#160;</td><td class="fielddoc">
<p>Atomic swap </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabd91e0300a53e38d28dbb53dfbb66c55adc79d547543b1803dace41a6bdea043c"></a>UCP_ATOMIC_FETCH_OP_CSWAP&#160;</td><td class="fielddoc">
<p>Atomic conditional swap </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabd91e0300a53e38d28dbb53dfbb66c55a072b82e2e35a90b7ed3e113423e6d5e3"></a>UCP_ATOMIC_FETCH_OP_FAND&#160;</td><td class="fielddoc">
<p>Atomic Fetch and and </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabd91e0300a53e38d28dbb53dfbb66c55a2b0b3779905ea67eea996ae8e296ed59"></a>UCP_ATOMIC_FETCH_OP_FOR&#160;</td><td class="fielddoc">
<p>Atomic Fetch and or </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabd91e0300a53e38d28dbb53dfbb66c55a86930c2cddc0a884cbf88ced6c330049"></a>UCP_ATOMIC_FETCH_OP_FXOR&#160;</td><td class="fielddoc">
<p>Atomic Fetch and xor </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabd91e0300a53e38d28dbb53dfbb66c55a2532883ac97f4ee8178b52318f978a05"></a>UCP_ATOMIC_FETCH_OP_LAST&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gab471a9c7ab815e3d3ad7af80253f5cc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___c_o_m_m.html#gab471a9c7ab815e3d3ad7af80253f5cc2">ucp_stream_recv_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enumeration defines behavior of <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a> function. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggab471a9c7ab815e3d3ad7af80253f5cc2a5fb4ed4f8009d969ea9a8b3f3542424c"></a>UCP_STREAM_RECV_FLAG_WAITALL&#160;</td><td class="fielddoc">
<p>This flag requests that operation will not be completed untill all amout of requested data is received and placed in the user buffer. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga9022ff0ebb56cac81f6ba81bb28f71b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_stream_send_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sends data that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>datatype</em> object to the destination endpoint <em>ep</em>. The routine is non-blocking and therefore returns immediately, however the actual send operation may be delayed. The send operation is considered completed when it is safe to reuse the source <em>buffer</em>. If the send operation is completed immediately the routine returns UCS_OK and the call-back function <em>cb</em> is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error reported, then the UCP library will schedule invocation of the call-back <em>cb</em> upon completion of the send operation. In other words, the completion of the operation will be signaled either by the return code or by the call-back.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> after this operation is called, until the operation completes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Destination endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the message buffer (payload). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that is invoked whenever the send operation is completed. It is important to note that the call-back is only invoked in a case when the operation cannot be completed in place. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Reserved for future use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - The send operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The send operation failed. </dd>
<dd>
otherwise - Operation was scheduled for send and can be completed in any point in time. The request handle is returned to the application in order to track progress of the message. The application is responsible to release the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free</a> routine. </dd></dl>

</div>
</div>
<a class="anchor" id="gaae7343bd638924e5518041311d5c1dfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_send_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine sends a messages that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>datatype</em> object to the destination endpoint <em>ep</em>. Each message is associated with a <em>tag</em> value that is used for message matching on the <a class="el" href="group___u_c_p___c_o_m_m.html#gaeb24cdfc33dfb2886551b51843aa6304">receiver</a>. The routine is non-blocking and therefore returns immediately, however the actual send operation may be delayed. The send operation is considered completed when it is safe to reuse the source <em>buffer</em>. If the send operation is completed immediately the routine return UCS_OK and the call-back function <em>cb</em> is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error reported then the UCP library will schedule to invoke the call-back <em>cb</em> whenever the send operation will be completed. In other words, the completion of a message can be signaled by the return code or the call-back.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> after this operation is called, until the operation completes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Destination endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the message buffer (payload). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that is invoked whenever the send operation is completed. It is important to note that the call-back is only invoked in a case when the operation cannot be completed in place.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - The send operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The send operation failed. </dd>
<dd>
otherwise - Operation was scheduled for send and can be completed in any point in time. The request handle is returned to the application in order to track progress of the message. The application is responsible to released the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ucp_hello_world_8c-example.html#a14">ucp_hello_world.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gad90aa964e14fef59b4e3bd9120cca669"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_tag_send_nbr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine provides a convenient and efficient way to implement a blocking send pattern. It also completes requests faster than <a class="el" href="group___u_c_p___c_o_m_m.html#gad90aa964e14fef59b4e3bd9120cca669">ucp_tag_send_nbr()</a> because: </p><ul>
<li>it always uses <a class="el" href="group___u_c_t___a_m.html#gae29dad6b69beaf21c19255906742e14d">uct_ep_am_bcopy()</a> to send data up to the rendezvous threshold. </li>
<li>its rendezvous threshold is higher than the one used by the <a class="el" href="group___u_c_p___c_o_m_m.html#gaae7343bd638924e5518041311d5c1dfc">ucp_tag_send_nb()</a>. The threshold is controlled by the <b>UCX_SEND_NBR_RNDV_THRESH</b> environment variable. </li>
<li>its request handling is simpler. There is no callback and no need to allocate and free requests. In fact request can be allocated by caller on the stack.</li>
</ul>
<p>This routine sends a messages that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>datatype</em> object to the destination endpoint <em>ep</em>. Each message is associated with a <em>tag</em> value that is used for message matching on the <a class="el" href="group___u_c_p___c_o_m_m.html#ga5a86663a4a144fd81d7a4e3378c5edd2">receiver</a>.</p>
<p>The routine is non-blocking and therefore returns immediately, however the actual send operation may be delayed. The send operation is considered completed when it is safe to reuse the source <em>buffer</em>. If the send operation is completed immediately the routine returns UCS_OK.</p>
<p>If the operation is <b>not</b> completed immediately and no error reported then the UCP library will fill a user provided <em>req</em> and return UCS_INPROGRESS status. In order to monitor completion of the operation <a class="el" href="group___u_c_p___c_o_m_m.html#gae082ad7af428645ebe6e469d3d06a757">ucp_request_check_status()</a> should be used.</p>
<p>Following pseudo code implements a blocking send function: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;MPI_send(...)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    char *request;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    ucs_status_t status;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    // allocate request on the stack</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    // ucp_context_query() was used to get ucp_request_size</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    request = alloca(ucp_request_size);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    // note: make sure that there is enough memory before the</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    // request handle</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    status = ucp_tag_send_nbr(ep, ..., request + ucp_request_size);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    if (status != UCS_INPROGRESS) {</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        return status;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    }</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    do {</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;        ucp_worker_progress(worker);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        status = ucp_request_check_status(request + ucp_request_size);</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    } while (status == UCS_INPROGRESS);</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    return status;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> after this operation is called, until the operation completes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Destination endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the message buffer (payload). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>Request handle allocated by the user. There should be at least UCP request size bytes of available space before the <em>req</em>. The size of UCP request can be obtained by <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga3485fb61663f4cc6f32e801654aedcff">ucp_context_query</a> function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - The send operation was completed immediately. </dd>
<dd>
UCS_INPROGRESS - The send was not completed and is in progress. <a class="el" href="group___u_c_p___c_o_m_m.html#gae082ad7af428645ebe6e469d3d06a757">ucp_request_check_status()</a> should be used to monitor <em>req</em> status. </dd>
<dd>
Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gabd3e1ccae2ef34463e8313d09d3db17f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_send_sync_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="group___u_c_p___c_o_m_m.html#gaae7343bd638924e5518041311d5c1dfc">ucp_tag_send_nb</a>, except the request completes only after there is a remote tag match on the message (which does not always mean the remote receive has been completed). This function never completes "in-place", and always returns a request handle.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>buffer</em> after this operation is called, until the operation completes. </dd>
<dd>
Returns <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a252c38290855ceaf849c04b7fa52dc23">UCS_ERR_UNSUPPORTED</a> if <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#gga7c69a28724d5ae3e49490e23e64df167aa31630259732e700b6ce0fe612cf0a6f">UCP_ERR_HANDLING_MODE_PEER</a> is enabled. This is a temporary implementation-related constraint that will be addressed in future releases.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Destination endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the message buffer (payload). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to send </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that is invoked whenever the send operation is completed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_PTR_IS_ERR(_ptr) - The send operation failed. </dd>
<dd>
otherwise - Operation was scheduled for send and can be completed in any point in time. The request handle is returned to the application in order to track progress of the message. The application is responsible to release the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
<a class="anchor" id="gadf3b4504a329a46d2d4ec0a8cec08130"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_stream_recv_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a6234b8497006e26ba02f10ddc0bbf5">ucp_stream_recv_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives data that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>datatype</em> object on the endpoint <em>ep</em>. The routine is non-blocking and therefore returns immediately. The receive operation is considered complete when the message is delivered to the buffer. If data is not immediately available, the operation will be scheduled for receive and a request handle will be returned. In order to notify the application about completion of a scheduled receive operation, the UCP library will invoke the call-back <em>cb</em> when data is in the receive buffer and ready for application access. If the receive operation cannot be started, the routine returns an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer to receive the data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive into <em>buffer</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that is invoked whenever the receive operation is completed and the data is ready in the receive <em>buffer</em>. It is important to note that the call-back is only invoked in a case when the operation cannot be completed immediately. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">length</td><td>Size of the received data in bytes. The value is valid only if return code is UCS_OK. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The amount of data received, in bytes, is always an integral multiple of the <em>datatype</em> size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags defined in <a class="el" href="group___u_c_p___c_o_m_m.html#gab471a9c7ab815e3d3ad7af80253f5cc2">ucp_stream_recv_flags_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - The receive operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The receive operation failed. </dd>
<dd>
otherwise - Operation was scheduled for receive. A request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle by calling the <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free</a> routine. </dd></dl>

</div>
</div>
<a class="anchor" id="ga47f307f4765eb5410f24ac27986b59d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_stream_recv_data_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives any available data from endpoint <em>ep</em>. Unlike <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a>, the returned data is unstructured and is treated as an array of bytes. If data is immediately available, UCS_STATUS_PTR(_ptr) is returned as a pointer to the data, and <em>length</em> is set to the size of the returned data buffer. The routine is non-blocking and therefore returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">length</td><td>Length of received data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - No received data available on the <em>ep</em>. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - the receive operation failed and UCS_PTR_STATUS(_ptr) indicates an error. </dd>
<dd>
otherwise - The pointer to the data UCS_STATUS_PTR(_ptr) is returned to the application. After the data is processed, the application is responsible for releasing the data buffer by calling the <a class="el" href="group___u_c_p___c_o_m_m.html#ga1d1c1c1b2caf4f26c9872e1d708d5f68">ucp_stream_data_release</a> routine.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function returns packed data (equivalent to <a class="el" href="group___u_c_p___d_a_t_a_t_y_p_e.html#ga9a56fc4636094bab740d77f7df70c2b5" title="Generate an identifier for contiguous data type. ">ucp_dt_make_contig(1)</a>). </dd>
<dd>
This function returns a pointer to a UCP-supplied buffer, whereas <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a> places the data into a user-provided buffer. In some cases, receiving data directly into a UCP-supplied buffer can be more optimal, for example by processing the incoming data in-place and thus avoiding extra memory copy operations. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb24cdfc33dfb2886551b51843aa6304"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_recv_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga00ac0fe5665d15fab5cd254af9b07758">ucp_tag_recv_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives a messages that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>datatype</em> object on the <em>worker</em>. The tag value of the receive message has to match the <em>tag</em> and <em>tag_mask</em> values, where the <em>tag_mask</em> indicates what bits of the tag have to be matched. The routine is a non-blocking and therefore returns immediately. The receive operation is considered completed when the message is delivered to the <em>buffer</em>. In order to notify the application about completion of the receive operation the UCP library will invoke the call-back <em>cb</em> when the received message is in the receive buffer and ready for application access. If the receive operation cannot be stated the routine returns an error.</p>
<dl class="section note"><dt>Note</dt><dd>This routine cannot return UCS_OK. It always returns a request handle or an error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer to receive the data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag_mask</td><td>Bit mask that indicates the bits that are used for the matching of the incoming tag against the expected tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that is invoked whenever the receive operation is completed and the data is ready in the receive <em>buffer</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_PTR_IS_ERR(_ptr) - The receive operation failed. </dd>
<dd>
otherwise - Operation was scheduled for receive. The request handle is returned to the application in order to track progress of the operation. The application is responsible to released the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5a86663a4a144fd81d7a4e3378c5edd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_tag_recv_nbr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>req</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives a message that is described by the local address <em>buffer</em>, size <em>count</em>, and <em>datatype</em> object on the <em>worker</em>. The tag value of the receive message has to match the <em>tag</em> and <em>tag_mask</em> values, where the <em>tag_mask</em> indicates what bits of the tag have to be matched. The routine is a non-blocking and therefore returns immediately. The receive operation is considered completed when the message is delivered to the <em>buffer</em>. In order to monitor completion of the operation <a class="el" href="group___u_c_p___c_o_m_m.html#gae082ad7af428645ebe6e469d3d06a757">ucp_request_check_status</a> or <a class="el" href="group___u_c_p___c_o_m_m.html#ga707cbbef8cdcf90fa7cf63c922ef2c7f">ucp_tag_recv_request_test</a> should be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer to receive the data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag to expect. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag_mask</td><td>Bit mask that indicates the bits that are used for the matching of the incoming tag against the expected tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>Request handle allocated by the user. There should be at least UCP request size bytes of available space before the <em>req</em>. The size of UCP request can be obtained by <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga3485fb61663f4cc6f32e801654aedcff">ucp_context_query</a> function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga41668f468dc37a7634116b8210815f22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a> ucp_tag_probe_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga55df42689ef1f5621eae4d1ffb16856e">ucp_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>remove</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine probes (checks) if a messages described by the <em>tag</em> and <em>tag_mask</em> was received (fully or partially) on the <em>worker</em>. The tag value of the received message has to match the <em>tag</em> and <em>tag_mask</em> values, where the <em>tag_mask</em> indicates what bits of the tag have to be matched. The function returns immediately and if the message is matched it returns a handle for the message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker that is used for the probe operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>Message tag to probe for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag_mask</td><td>Bit mask that indicates the bits that are used for the matching of the incoming tag against the expected tag. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove</td><td>The flag indicates if the matched message has to be removed from UCP library. If true (1), the message handle is removed from the UCP library and the application is responsible to call <a class="el" href="group___u_c_p___c_o_m_m.html#gac335b3ae4c9577728d9c0f2ecd44c084">ucp_tag_msg_recv_nb()</a> in order to receive the data and release the resources associated with the message handle. If false (0), the return value is merely an indication to whether a matching message is present, and it cannot be used in any other way, and in particular it cannot be passed to <a class="el" href="group___u_c_p___c_o_m_m.html#gac335b3ae4c9577728d9c0f2ecd44c084">ucp_tag_msg_recv_nb()</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>If the matching message is found the descriptor is filled with the details about the message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL - No match found. </dd>
<dd>
Message handle (not NULL) - If message is matched the message handle is returned.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function does not advance the communication state of the network. If this routine is used in busy-poll mode, need to make sure <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga340784a8528d4932916651460dc481c0">ucp_worker_progress()</a> is called periodically to extract messages from the transport. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ucp_hello_world_8c-example.html#a17">ucp_hello_world.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gac335b3ae4c9577728d9c0f2ecd44c084"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_tag_msg_recv_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gae461587956dd56a6bc7d67b027845891">ucp_datatype_t</a>&#160;</td>
          <td class="paramname"><em>datatype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga6a8b5741a4e66d7e890d31ef7cbf88ec">ucp_tag_message_h</a>&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#ga00ac0fe5665d15fab5cd254af9b07758">ucp_tag_recv_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine receives a messages that is described by the local address <em>buffer</em>, size <em>count</em>, <em>message</em> handle, and <em>datatype</em> object on the <em>worker</em>. The <em>message</em> handle can be obtain by calling the <a class="el" href="group___u_c_p___c_o_m_m.html#ga41668f468dc37a7634116b8210815f22">ucp_tag_probe_nb()</a> routine. <a class="el" href="group___u_c_p___c_o_m_m.html#gac335b3ae4c9577728d9c0f2ecd44c084">ucp_tag_msg_recv_nb()</a> routine is a non-blocking and therefore returns immediately. The receive operation is considered completed when the message is delivered to the <em>buffer</em>. In order to notify the application about completion of the receive operation the UCP library will invoke the call-back <em>cb</em> when the received message is in the receive buffer and ready for application access. If the receive operation cannot be stated the routine returns an error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker that is used for the receive operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the buffer to receive the data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>Number of elements to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">datatype</td><td>Datatype descriptor for the elements in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>Message handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback function that is invoked whenever the receive operation is completed and the data is ready in the receive <em>buffer</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_PTR_IS_ERR(_ptr) - The receive operation failed. </dd>
<dd>
otherwise - Operation was scheduled for receive. The request handle is returned to the application in order to track progress of the operation. The application is responsible to released the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ucp_hello_world_8c-example.html#a19">ucp_hello_world.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga77f3d5def7a77c4ba88f9e1eefa4b7e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_put_nbi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine initiates a storage of contiguous block of data that is described by the local address <em>buffer</em> in the remote contiguous memory region described by <em>remote_addr</em> address and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory</a>handle" <em>rkey</em>. The routine returns immediately and <b>does</b> <b>not</b> guarantee re-usability of the source address <em>buffer</em>. If the operation is completed immediately the routine return UCS_OK, otherwise UCS_INPROGRESS or an error is returned to user.</p>
<dl class="section note"><dt>Note</dt><dd>A user can use <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb()</a> in order to guarantee re-usability of the source address <em>buffer</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data (in bytes) stored under the source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote memory address to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote memory address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ba986b2bde69c215abd5766dbceeb18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_put_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine initiates a storage of contiguous block of data that is described by the local address <em>buffer</em> in the remote contiguous memory region described by <em>remote_addr</em> address and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory</a>handle" <em>rkey</em>. The routine returns immediately and <b>does</b> <b>not</b> guarantee re-usability of the source address <em>buffer</em>. If the operation is completed immediately the routine return UCS_OK, otherwise UCS_INPROGRESS or an error is returned to user. If the put operation completes immediately, the routine returns UCS_OK and the call-back routine <em>cb</em> is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error is reported, then the UCP library will schedule invocation of the call-back routine <em>cb</em> upon completion of the put operation. In other words, the completion of a put operation can be signaled by the return code or execution of the call-back.</p>
<dl class="section note"><dt>Note</dt><dd>A user can use <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb()</a> in order to guarantee re-usability of the source address <em>buffer</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data (in bytes) stored under the source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote memory address to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Call-back function that is invoked whenever the put operation is completed and the local buffer can be modified. Does not guarantee remote completion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - The operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The operation failed. </dd>
<dd>
otherwise - Operation was scheduled and can be completed at any point in time. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
<a class="anchor" id="gae3597f699227d598651f6630fbd7968b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_get_nbi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine initiate a load of contiguous block of data that is described by the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory handle</a> <em>rkey</em> in the local contiguous memory region described by <em>buffer</em> address. The routine returns immediately and <b>does</b> <b>not</b> guarantee that remote data is loaded and stored under the local address <em>buffer</em>.</p>
<dl class="section note"><dt>Note</dt><dd>A user can use <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb()</a> in order guarantee that remote data is loaded and stored under the local address <em>buffer</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data (in bytes) stored under the source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote memory address to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote memory address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7cb68811f53a69d37fd16e8ddb46e23b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_get_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine initiates a load of a contiguous block of data that is described by the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory handle</a> <em>rkey</em> in the local contiguous memory region described by <em>buffer</em> address. The routine returns immediately and <b>does</b> <b>not</b> guarantee that remote data is loaded and stored under the local address <em>buffer</em>. If the operation is completed immediately the routine return UCS_OK, otherwise UCS_INPROGRESS or an error is returned to user. If the get operation completes immediately, the routine returns UCS_OK and the call-back routine <em>cb</em> is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error is reported, then the UCP library will schedule invocation of the call-back routine <em>cb</em> upon completion of the get operation. In other words, the completion of a get operation can be signaled by the return code or execution of the call-back.</p>
<dl class="section note"><dt>Note</dt><dd>A user can use <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb()</a> in order to guarantee re-usability of the source address <em>buffer</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data (in bytes) stored under the source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote memory address to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Call-back function that is invoked whenever the get operation is completed and the data is visible to the local process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - The operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The operation failed. </dd>
<dd>
otherwise - Operation was scheduled and can be completed at any point in time. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
<a class="anchor" id="ga839312fb4de5e786daacb4fa071d61df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_post </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gac5d94ea07dc4feae2708e67378ba2ad0">ucp_atomic_post_op_t</a>&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>op_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine posts an atomic memory operation to a remote value. The remote value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. Return from the function does not guarantee completion. A user must call <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga599c9b9272bfdd662afaa247d8e4dfd6">ucp_ep_flush_nb</a> or <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb</a> to guarantee that the remote value has been updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opcode</td><td>One of <a class="el" href="group___u_c_p___c_o_m_m.html#gac5d94ea07dc4feae2708e67378ba2ad0">ucp_atomic_post_op_t</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Source operand for the atomic operation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op_size</td><td>Size of value in bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Remote address to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote key handle for the remote memory address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga43a1a4a517797eb8c5c96ac8841437de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_atomic_fetch_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gabd91e0300a53e38d28dbb53dfbb66c55">ucp_atomic_fetch_op_t</a>&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>op_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine will post an atomic fetch operation to remote memory. The remote value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The routine is non-blocking and therefore returns immediately. However the actual atomic operation may be delayed. The atomic operation is not considered complete until the values in remote and local memory are completed. If the atomic operation completes immediately, the routine returns UCS_OK and the call-back routine <em>cb</em> is <b>not</b> invoked. If the operation is <b>not</b> completed immediately and no error is reported, then the UCP library will schedule invocation of the call-back routine <em>cb</em> upon completion of the atomic operation. In other words, the completion of an atomic operation can be signaled by the return code or execution of the call-back.</p>
<dl class="section note"><dt>Note</dt><dd>The user should not modify any part of the <em>result</em> after this operation is called, until the operation completes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>UCP endpoint. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">opcode</td><td>One of <a class="el" href="group___u_c_p___c_o_m_m.html#gabd91e0300a53e38d28dbb53dfbb66c55">ucp_atomic_fetch_op_t</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Source operand for atomic operation. In the case of CSWAP this is the conditional for the swap. For SWAP this is the value to be placed in remote memory. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">result</td><td>Local memory address to store resulting fetch to. In the case of CSWAP the value in result will be swapped into the <em>remote_addr</em> if the condition is true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op_size</td><td>Size of value in bytes and pointer type for result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Remote address to operate on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote key handle for the remote memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Call-back function that is invoked whenever the send operation is completed. It is important to note that the call-back function is only invoked in a case when the operation cannot be completed in place.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - The operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The operation failed. </dd>
<dd>
otherwise - Operation was scheduled and can be completed at any point in time. The request handle is returned to the application in order to track progress of the operation. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
<a class="anchor" id="gae082ad7af428645ebe6e469d3d06a757"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_request_check_status </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine checks the state of the request and returns its current status. Any value different from UCS_INPROGRESS means that request is in a completed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Non-blocking request to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ucp_hello_world_8c-example.html#a22">ucp_hello_world.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga707cbbef8cdcf90fa7cf63c922ef2c7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_tag_recv_request_test </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga118ca6feabfc3b35c7b37002c40ca7e2">ucp_tag_recv_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine checks the state and returns current status of the request returned from <a class="el" href="group___u_c_p___c_o_m_m.html#gaeb24cdfc33dfb2886551b51843aa6304">ucp_tag_recv_nb</a> routine or the user allocated request for <a class="el" href="group___u_c_p___c_o_m_m.html#ga5a86663a4a144fd81d7a4e3378c5edd2">ucp_tag_recv_nbr</a>. Any value different from UCS_INPROGRESS means that the request is in a completed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Non-blocking request to check. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>It is filled with the details about the message available at the moment of calling.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d8d8823b24cb25dcab8bf44c72fa25e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_stream_recv_request_test </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>length_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine checks the state and returns current status of the request returned from <a class="el" href="group___u_c_p___c_o_m_m.html#gadf3b4504a329a46d2d4ec0a8cec08130">ucp_stream_recv_nb</a> routine. Any value different from UCS_INPROGRESS means that the request is in a completed state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Non-blocking request to check. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">length_p</td><td>The size of the received data in bytes. This value is only valid if the status is UCS_OK. If valid, it is always an integral multiple of the datatype size associated with the request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3553f89a61d6b40af4633a2e7c84fc1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_request_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Non-blocking request to cancel.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine tries to cancels an outstanding communication request. After calling this routine, the <em>request</em> will be in completed or canceled (but not both) state regardless of the status of the target endpoint associated with the communication request. If the request is completed successfully, the <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">send</a> or <a class="el" href="group___u_c_p___c_o_m_m.html#ga00ac0fe5665d15fab5cd254af9b07758">receive</a> completion callbacks (based on the type of the request) will be called with the <em>status</em> argument of the callback set to UCS_OK, and in a case it is canceled the <em>status</em> argument is set to UCS_ERR_CANCELED. It is important to note that in order to release the request back to the library the application is responsible to call <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a>. </p>

</div>
</div>
<a class="anchor" id="ga1d1c1c1b2caf4f26c9872e1d708d5f68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_stream_data_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint <em>data</em> received from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data pointer to release, which was returned from <a class="el" href="group___u_c_p___c_o_m_m.html#ga47f307f4765eb5410f24ac27986b59d7">ucp_stream_recv_data_nb</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine releases internal UCP data buffer returned by <a class="el" href="group___u_c_p___c_o_m_m.html#ga47f307f4765eb5410f24ac27986b59d7">ucp_stream_recv_data_nb</a> when <em>data</em> is processed, the application can't use this buffer after calling this function. </p>

</div>
</div>
<a class="anchor" id="ga0e8e46f5953d464382b21edef3ec9994"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_request_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>Non-blocking request to release.</td></tr>
  </table>
  </dd>
</dl>
<p>This routine releases the non-blocking request back to the library, regardless of its current state. Communications operations associated with this request will make progress internally, however no further notifications or callbacks would be invoked for this request. </p>

</div>
</div>
<a class="anchor" id="ga432e478b97575b21855074a45d54520d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ucp_request_is_completed </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga3802a983138ed27034b7d52026dccb2f">ucp_request_test</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85b0a27cf8a3239decabad6a9104eb31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000009">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga1ba986b2bde69c215abd5766dbceeb18">ucp_put_nb</a>. The following example implements the same functionality using <a class="el" href="group___u_c_p___c_o_m_m.html#ga1ba986b2bde69c215abd5766dbceeb18">ucp_put_nb</a> : <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void empty_callback(void *request, ucs_status_t status)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;ucs_status_t put(ucp_ep_h ep, const void *buffer, size_t length,</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;                  uint64_t remote_addr, ucp_rkey_h rkey)</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;{</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    void *request = ucp_put_nb(ep, buffer, length, remote_addr, rkey,</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;                               empty_callback),</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    if (request == NULL) {</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;        return UCS_OK;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    } else if (UCS_PTR_IS_ERR(request)) {</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        return UCS_PTR_STATUS(request);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    } else {</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        ucs_status_t status;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        do {</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;            ucp_worker_progress(worker);</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;            status = ucp_request_check_status(request);</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;        } while (status == UCS_INPROGRESS);</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;        ucp_request_release(request);</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        return status;</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    }</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<p>This routine stores contiguous block of data that is described by the local address <em>buffer</em> in the remote contiguous memory region described by <em>remote_addr</em> address and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory handle</a> <em>rkey</em>. The routine returns when it is safe to reuse the source address <em>buffer</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data (in bytes) stored under the source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf4a465cff6c1691106430564899f6f3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000010">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga7cb68811f53a69d37fd16e8ddb46e23b">ucp_get_nb</a>. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation. ">ucp_put</a>.</dd></dl>
</dd></dl>
<p>This routine loads contiguous block of data that is described by the remote address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">memory handle</a> <em>rkey</em> in the local contiguous memory region described by <em>buffer</em> address. The routine returns when remote data is loaded and stored under the local address <em>buffer</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to the local source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of the data (in bytes) stored under the source address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa042d7e76314e1d7ea9717d4adacde7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_add32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000011">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga839312fb4de5e786daacb4fa071d61df">ucp_atomic_post</a> with opcode UCP_ATOMIC_POST_OP_ADD. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation. ">ucp_put</a>.</dd></dl>
</dd></dl>
<p>This routine performs an add operation on a 32 bit integer value atomically. The remote integer value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <em>add</em> value is the value that is used for the add operation. When the operation completes the sum of the original remote value and the operand value (<em>add</em>) is stored in remote memory. The call to the routine returns immediately, independent of operation completion.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 32 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add</td><td>Value to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa80cd3f104b920c0c2f6bf7cff50fc15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_add64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000012">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga839312fb4de5e786daacb4fa071d61df">ucp_atomic_post</a> with opcode UCP_ATOMIC_POST_OP_ADD. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation. ">ucp_put</a>.</dd></dl>
</dd></dl>
<p>This routine performs an add operation on a 64 bit integer value atomically. The remote integer value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <em>add</em> value is the value that is used for the add operation. When the operation completes the sum of the original remote value and the operand value (<em>add</em>) is stored in remote memory. The call to the routine returns immediately, independent of operation completion.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 64 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add</td><td>Value to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga0c777d7d1c59e01151ef5e3fcd7e5b94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_fadd32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000013">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> with opcode UCP_ATOMIC_FETCH_OP_FADD. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation. ">ucp_put</a>.</dd></dl>
</dd></dl>
<p>This routine performs an add operation on a 32 bit integer value atomically. The remote integer value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <em>add</em> value is the value that is used for the add operation. When the operation completes, the original remote value is stored in the local memory <em>result</em>, and the sum of the original remote value and the operand value is stored in remote memory. The call to the routine returns when the operation is completed and the <em>result</em> value is updated.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 32 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add</td><td>Value to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to the address that is used to store the previous value of the atomic variable described by the <em>remote_addr</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7435bc5d5e2c4fb6b491d457ab65596b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_fadd64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> with opcode UCP_ATOMIC_FETCH_OP_FADD. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation. ">ucp_put</a>.</dd></dl>
</dd></dl>
<p>This routine performs an add operation on a 64 bit integer value atomically. The remote integer value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <em>add</em> value is the value that is used for the add operation. When the operation completes, the original remote value is stored in the local memory <em>result</em>, and the sum of the original remote value and the operand value is stored in remote memory. The call to the routine returns when the operation is completed and the <em>result</em> value is updated.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 64 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">add</td><td>Value to add. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to the address that is used to store the previous value of the atomic variable described by the <em>remote_addr</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga43118f9d5e6d8fdfa518887218468bb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_swap32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000015">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> with opcode UCP_ATOMIC_FETCH_OP_SWAP. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation. ">ucp_put</a>.</dd></dl>
</dd></dl>
<p>This routine swaps a 32 bit value between local and remote memory. The remote value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <em>swap</em> value is the value that is used for the swap operation. When the operation completes, the remote value is stored in the local memory <em>result</em>, and the operand value (<em>swap</em>) is stored in remote memory. The call to the routine returns when the operation is completed and the <em>result</em> value is updated.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 32 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap</td><td>Value to swap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to the address that is used to store the previous value of the atomic variable described by the <em>remote_addr</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa2913e345505195a183ccc2583fb4ebc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_swap64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>swap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> with opcode UCP_ATOMIC_FETCH_OP_SWAP. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation. ">ucp_put</a>.</dd></dl>
</dd></dl>
<p>This routine swaps a 64 bit value between local and remote memory. The remote value is described by the combination of the remote memory address <em>remote_addr</em> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <em>swap</em> value is the value that is used for the swap operation. When the operation completes, the remote value is stored in the local memory <em>result</em>, and the operand value (<em>swap</em>) is stored in remote memory. The call to the routine returns when the operation is completed and the <em>result</em> value is updated.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 64 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap</td><td>Value to swap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to the address that is used to store the previous value of the atomic variable described by the <em>remote_addr</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6078dddaa93c8dfdab3c18014064f0c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_cswap32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> with opcode UCP_ATOMIC_FETCH_OP_CSWAP. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation. ">ucp_put</a>.</dd></dl>
</dd></dl>
<p>This routine conditionally swaps a 32 bit value between local and remote memory. The swap occurs only if the condition value (<em>continue</em>) is equal to the remote value, otherwise the remote memory is not modified. The remote value is described by the combination of the remote memory address <code>remote_addr</code> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <code>swap</code> value is the value that is used to update the remote memory if the condition is true. The call to the routine returns when the operation is completed and the <em>result</em> value is updated.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 32 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>Value to compare to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap</td><td>Value to swap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to the address that is used to store the previous value of the atomic variable described by the <em>remote_addr</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafa365c16d4c2b4fd2aba6e94fec2c92b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_atomic_cswap64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>compare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>swap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>remote_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">ucp_rkey_h</a>&#160;</td>
          <td class="paramname"><em>rkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___c_o_m_m.html#ga43a1a4a517797eb8c5c96ac8841437de">ucp_atomic_fetch_nb</a> with opcode UCP_ATOMIC_FETCH_OP_CSWAP. <dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_c_p___c_o_m_m.html#ga85b0a27cf8a3239decabad6a9104eb31" title="Blocking remote memory put operation. ">ucp_put</a>.</dd></dl>
</dd></dl>
<p>This routine conditionally swaps a 64 bit value between local and remote memory. The swap occurs only if the condition value (<em>continue</em>) is equal to the remote value, otherwise the remote memory is not modified. The remote value is described by the combination of the remote memory address <code>remote_addr</code> and the <a class="el" href="group___u_c_p___m_e_m.html#gaefeb4e775983f4313691a6b465e36c24">remote memory handle</a> <em>rkey</em>. The <code>swap</code> value is the value that is used to update the remote memory if the condition is true. The call to the routine returns when the operation is completed and the <em>result</em> value is updated.</p>
<dl class="section note"><dt>Note</dt><dd>The remote address must be aligned to 64 bit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Remote endpoint handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>Value to compare to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">swap</td><td>Value to swap. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remote_addr</td><td>Pointer to the destination remote address of the atomic variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rkey</td><td>Remote memory key associated with the remote address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Pointer to the address that is used to store the previous value of the atomic variable described by the <em>remote_addr</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Feb 17 2019 17:26:30 for UCX by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
