<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>UCX: UCP Worker</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="UCX_Logo_80x80.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">UCX
   &#160;<span id="projectnumber">1.6</span>
   </div>
   <div id="projectbrief">Unified Communication X</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Programming&#160;Interface</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___u_c_p___w_o_r_k_e_r.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UCP Worker<div class="ingroups"><a class="el" href="group___u_c_p___a_p_i.html">Unified Communication Protocol (UCP) API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structucp__worker__attr"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#structucp__worker__attr">ucp_worker_attr</a></td></tr>
<tr class="memdesc:structucp__worker__attr"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP worker attributes.  <a href="group___u_c_p___w_o_r_k_e_r.html#structucp__worker__attr">More...</a><br /></td></tr>
<tr class="separator:structucp__worker__attr"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structucp__worker__params"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#structucp__worker__params">ucp_worker_params</a></td></tr>
<tr class="memdesc:structucp__worker__params"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuning parameters for the UCP worker.  <a href="group___u_c_p___w_o_r_k_e_r.html#structucp__worker__params">More...</a><br /></td></tr>
<tr class="separator:structucp__worker__params"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structucp__listener__params"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#structucp__listener__params">ucp_listener_params</a></td></tr>
<tr class="memdesc:structucp__listener__params"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for a UCP listener object.  <a href="group___u_c_p___w_o_r_k_e_r.html#structucp__listener__params">More...</a><br /></td></tr>
<tr class="separator:structucp__listener__params"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structucp__listener__accept__handler"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#structucp__listener__accept__handler">ucp_listener_accept_handler</a></td></tr>
<tr class="separator:structucp__listener__accept__handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structucp__listener__conn__handler"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#structucp__listener__conn__handler">ucp_listener_conn_handler</a></td></tr>
<tr class="memdesc:structucp__listener__conn__handler"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP callback to handle the connection request in a client-server connection establishment flow.  <a href="group___u_c_p___w_o_r_k_e_r.html#structucp__listener__conn__handler">More...</a><br /></td></tr>
<tr class="separator:structucp__listener__conn__handler"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga27a9d7a36ee31d7718f6ec2819108d07"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#structucp__worker__attr">ucp_worker_attr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga27a9d7a36ee31d7718f6ec2819108d07">ucp_worker_attr_t</a></td></tr>
<tr class="memdesc:ga27a9d7a36ee31d7718f6ec2819108d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP worker attributes.  <a href="#ga27a9d7a36ee31d7718f6ec2819108d07">More...</a><br /></td></tr>
<tr class="separator:ga27a9d7a36ee31d7718f6ec2819108d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aad09f7b71f912abe0b120872a236f2"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#structucp__worker__params">ucp_worker_params</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga7aad09f7b71f912abe0b120872a236f2">ucp_worker_params_t</a></td></tr>
<tr class="memdesc:ga7aad09f7b71f912abe0b120872a236f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuning parameters for the UCP worker.  <a href="#ga7aad09f7b71f912abe0b120872a236f2">More...</a><br /></td></tr>
<tr class="separator:ga7aad09f7b71f912abe0b120872a236f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2603bc15f79df18099f98b2254afab04"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#structucp__listener__params">ucp_listener_params</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga2603bc15f79df18099f98b2254afab04">ucp_listener_params_t</a></td></tr>
<tr class="memdesc:ga2603bc15f79df18099f98b2254afab04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for a UCP listener object.  <a href="#ga2603bc15f79df18099f98b2254afab04">More...</a><br /></td></tr>
<tr class="separator:ga2603bc15f79df18099f98b2254afab04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8b65bba266c848ca394ec48da48bc18"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#structucp__listener__accept__handler">ucp_listener_accept_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gad8b65bba266c848ca394ec48da48bc18">ucp_listener_accept_handler_t</a></td></tr>
<tr class="separator:gad8b65bba266c848ca394ec48da48bc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d24d2759c1375bf4d2d639e3b701956"><td class="memItemLeft" align="right" valign="top">typedef struct ucp_address&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga7d24d2759c1375bf4d2d639e3b701956">ucp_address_t</a></td></tr>
<tr class="memdesc:ga7d24d2759c1375bf4d2d639e3b701956"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP worker address.  <a href="#ga7d24d2759c1375bf4d2d639e3b701956">More...</a><br /></td></tr>
<tr class="separator:ga7d24d2759c1375bf4d2d639e3b701956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0496f7102c43cf339cc760b9e5724a2"><td class="memItemLeft" align="right" valign="top">typedef struct ucp_listener *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac0496f7102c43cf339cc760b9e5724a2">ucp_listener_h</a></td></tr>
<tr class="memdesc:gac0496f7102c43cf339cc760b9e5724a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP listen handle.  <a href="#gac0496f7102c43cf339cc760b9e5724a2">More...</a><br /></td></tr>
<tr class="separator:gac0496f7102c43cf339cc760b9e5724a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fd52efba31d20fc52055bb19270729f"><td class="memItemLeft" align="right" valign="top">typedef struct ucp_worker *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a></td></tr>
<tr class="memdesc:ga5fd52efba31d20fc52055bb19270729f"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP Worker.  <a href="#ga5fd52efba31d20fc52055bb19270729f">More...</a><br /></td></tr>
<tr class="separator:ga5fd52efba31d20fc52055bb19270729f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a1d61f9a3c1fd97c008dd77ae86c02c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga9a1d61f9a3c1fd97c008dd77ae86c02c">ucp_listener_accept_callback_t</a>) (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *arg)</td></tr>
<tr class="memdesc:ga9a1d61f9a3c1fd97c008dd77ae86c02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback for accepting client/server connections on a listener <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac0496f7102c43cf339cc760b9e5724a2">ucp_listener_h</a>.  <a href="#ga9a1d61f9a3c1fd97c008dd77ae86c02c">More...</a><br /></td></tr>
<tr class="separator:ga9a1d61f9a3c1fd97c008dd77ae86c02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga389a8cfa253f87eb9d8cc7b8d4747c82"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga389a8cfa253f87eb9d8cc7b8d4747c82">ucp_listener_conn_callback_t</a>) (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga200570bfa7d3a8b50b2a074aaa22d2ed">ucp_conn_request_h</a> conn_request, void *arg)</td></tr>
<tr class="memdesc:ga389a8cfa253f87eb9d8cc7b8d4747c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback for handling of incoming connection request <em>conn_request</em> from a client.  <a href="#ga389a8cfa253f87eb9d8cc7b8d4747c82">More...</a><br /></td></tr>
<tr class="separator:ga389a8cfa253f87eb9d8cc7b8d4747c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga558f048d85d5600f95c2f733ddc6b3e8"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#structucp__listener__conn__handler">ucp_listener_conn_handler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga558f048d85d5600f95c2f733ddc6b3e8">ucp_listener_conn_handler_t</a></td></tr>
<tr class="memdesc:ga558f048d85d5600f95c2f733ddc6b3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP callback to handle the connection request in a client-server connection establishment flow.  <a href="#ga558f048d85d5600f95c2f733ddc6b3e8">More...</a><br /></td></tr>
<tr class="separator:ga558f048d85d5600f95c2f733ddc6b3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae454437b2f4d1bd23dfc8975bbe60c2e"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga66be8946dcd33051d40ceca65ba28e22">ucp_wakeup_event_types</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gae454437b2f4d1bd23dfc8975bbe60c2e">ucp_wakeup_event_t</a></td></tr>
<tr class="memdesc:gae454437b2f4d1bd23dfc8975bbe60c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP worker wakeup events mask.  <a href="#gae454437b2f4d1bd23dfc8975bbe60c2e">More...</a><br /></td></tr>
<tr class="separator:gae454437b2f4d1bd23dfc8975bbe60c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gadbfc8fd5eaa65351d1617f2f158b80f6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gadbfc8fd5eaa65351d1617f2f158b80f6">ucp_worker_params_field</a> { <br />
&#160;&#160;<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ggadbfc8fd5eaa65351d1617f2f158b80f6a651598f7340d42cafb0876d918c83ec8">UCP_WORKER_PARAM_FIELD_THREAD_MODE</a> = UCS_BIT(0), 
<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ggadbfc8fd5eaa65351d1617f2f158b80f6a0ba499461804b26850d6a530609e228d">UCP_WORKER_PARAM_FIELD_CPU_MASK</a> = UCS_BIT(1), 
<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ggadbfc8fd5eaa65351d1617f2f158b80f6ac756667325d053bd1cc11cccf853b0c9">UCP_WORKER_PARAM_FIELD_EVENTS</a> = UCS_BIT(2), 
<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ggadbfc8fd5eaa65351d1617f2f158b80f6a1243d403aeceab36eee6d9cb985e8eb0">UCP_WORKER_PARAM_FIELD_USER_DATA</a> = UCS_BIT(3), 
<br />
&#160;&#160;<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ggadbfc8fd5eaa65351d1617f2f158b80f6ae743c2d23a0d7b0a9a8c6362a7611139">UCP_WORKER_PARAM_FIELD_EVENT_FD</a> = UCS_BIT(4)
<br />
 }<tr class="memdesc:gadbfc8fd5eaa65351d1617f2f158b80f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP worker parameters field mask.  <a href="group___u_c_p___w_o_r_k_e_r.html#gadbfc8fd5eaa65351d1617f2f158b80f6">More...</a><br /></td></tr>
<tr class="separator:gadbfc8fd5eaa65351d1617f2f158b80f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ga36d95269fcce844261494cbd4f5e26fc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga36d95269fcce844261494cbd4f5e26fc">ucp_listener_params_field</a> { <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gga36d95269fcce844261494cbd4f5e26fca0eed5ab19654fabc0afceb5b439c6f05">UCP_LISTENER_PARAM_FIELD_SOCK_ADDR</a> = UCS_BIT(0), 
<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gga36d95269fcce844261494cbd4f5e26fca3cdf187536d998c115377f8de396ac66">UCP_LISTENER_PARAM_FIELD_ACCEPT_HANDLER</a> = UCS_BIT(1), 
<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gga36d95269fcce844261494cbd4f5e26fca6f28cd3c96e0ada4fafc63d6f67e48bc">UCP_LISTENER_PARAM_FIELD_CONN_HANDLER</a> = UCS_BIT(2)
 }<tr class="memdesc:ga36d95269fcce844261494cbd4f5e26fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP listener parameters field mask.  <a href="group___u_c_p___w_o_r_k_e_r.html#ga36d95269fcce844261494cbd4f5e26fc">More...</a><br /></td></tr>
<tr class="separator:ga36d95269fcce844261494cbd4f5e26fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:gab1ec638cc4a7498a85017d132492d195"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gab1ec638cc4a7498a85017d132492d195">ucp_worker_address_flags_t</a> { <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ggab1ec638cc4a7498a85017d132492d195af9fe9ee3edc7fe21c889437941bb4117">UCP_WORKER_ADDRESS_FLAG_NET_ONLY</a> = UCS_BIT(0)
 }<tr class="memdesc:gab1ec638cc4a7498a85017d132492d195"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP worker address flags.  <a href="group___u_c_p___w_o_r_k_e_r.html#gab1ec638cc4a7498a85017d132492d195">More...</a><br /></td></tr>
<tr class="separator:gab1ec638cc4a7498a85017d132492d195"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:gacf03ee299a48c2f9c776516cc82c7194"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gacf03ee299a48c2f9c776516cc82c7194">ucp_worker_attr_field</a> { <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ggacf03ee299a48c2f9c776516cc82c7194a6d3178929ef9e6570999384991fbd42d">UCP_WORKER_ATTR_FIELD_THREAD_MODE</a> = UCS_BIT(0), 
<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ggacf03ee299a48c2f9c776516cc82c7194a0dde53e12c0ab222ddcf2a52984fddd2">UCP_WORKER_ATTR_FIELD_ADDRESS</a> = UCS_BIT(1), 
<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ggacf03ee299a48c2f9c776516cc82c7194a9b007ce57d2935817f86b4c4c6aad8c9">UCP_WORKER_ATTR_FIELD_ADDRESS_FLAGS</a> = UCS_BIT(2)
 }<tr class="memdesc:gacf03ee299a48c2f9c776516cc82c7194"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP worker attributes field mask.  <a href="group___u_c_p___w_o_r_k_e_r.html#gacf03ee299a48c2f9c776516cc82c7194">More...</a><br /></td></tr>
<tr class="separator:gacf03ee299a48c2f9c776516cc82c7194"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ga66be8946dcd33051d40ceca65ba28e22"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga66be8946dcd33051d40ceca65ba28e22">ucp_wakeup_event_types</a> { <br />
&#160;&#160;<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gga66be8946dcd33051d40ceca65ba28e22a80fc6d63077023d905d9f3adfb37c50a">UCP_WAKEUP_RMA</a> = UCS_BIT(0), 
<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gga66be8946dcd33051d40ceca65ba28e22a1f8891a39fe63593947811936a9af8f7">UCP_WAKEUP_AMO</a> = UCS_BIT(1), 
<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gga66be8946dcd33051d40ceca65ba28e22a136d0a608b0dcceb731d3022f1cb0e91">UCP_WAKEUP_TAG_SEND</a> = UCS_BIT(2), 
<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gga66be8946dcd33051d40ceca65ba28e22a15bd79b8acc9815513dccf43fc350435">UCP_WAKEUP_TAG_RECV</a> = UCS_BIT(3), 
<br />
&#160;&#160;<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gga66be8946dcd33051d40ceca65ba28e22ad70899effbabed3294c35b9b0f2a747b">UCP_WAKEUP_TX</a> = UCS_BIT(10), 
<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gga66be8946dcd33051d40ceca65ba28e22a182a353c533fc335e638e41fdaf7c6b5">UCP_WAKEUP_RX</a> = UCS_BIT(11), 
<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gga66be8946dcd33051d40ceca65ba28e22a474ecc6ca013d28f71ade5d85aafd1c8">UCP_WAKEUP_EDGE</a> = UCS_BIT(16)
<br />
 }<tr class="memdesc:ga66be8946dcd33051d40ceca65ba28e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">UCP worker wakeup events mask.  <a href="group___u_c_p___w_o_r_k_e_r.html#ga66be8946dcd33051d40ceca65ba28e22">More...</a><br /></td></tr>
<tr class="separator:ga66be8946dcd33051d40ceca65ba28e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0aec01ed3dad646ca6cd3814b13054b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga0aec01ed3dad646ca6cd3814b13054b1">ucp_worker_create</a> (<a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">ucp_context_h</a> context, const <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga7aad09f7b71f912abe0b120872a236f2">ucp_worker_params_t</a> *params, <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> *worker_p)</td></tr>
<tr class="memdesc:ga0aec01ed3dad646ca6cd3814b13054b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a worker object.  <a href="#ga0aec01ed3dad646ca6cd3814b13054b1">More...</a><br /></td></tr>
<tr class="separator:ga0aec01ed3dad646ca6cd3814b13054b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b6c5bf97d16e7fc4b7c815875e92676"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga6b6c5bf97d16e7fc4b7c815875e92676">ucp_worker_destroy</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker)</td></tr>
<tr class="memdesc:ga6b6c5bf97d16e7fc4b7c815875e92676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a worker object.  <a href="#ga6b6c5bf97d16e7fc4b7c815875e92676">More...</a><br /></td></tr>
<tr class="separator:ga6b6c5bf97d16e7fc4b7c815875e92676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab678930b792e328eb4f0a17654e5e42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gaab678930b792e328eb4f0a17654e5e42">ucp_worker_query</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga27a9d7a36ee31d7718f6ec2819108d07">ucp_worker_attr_t</a> *attr)</td></tr>
<tr class="memdesc:gaab678930b792e328eb4f0a17654e5e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get attributes specific to a particular worker.  <a href="#gaab678930b792e328eb4f0a17654e5e42">More...</a><br /></td></tr>
<tr class="separator:gaab678930b792e328eb4f0a17654e5e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab746c6cccbfe8d25a892eb415bcedd97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gab746c6cccbfe8d25a892eb415bcedd97">ucp_worker_print_info</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, FILE *stream)</td></tr>
<tr class="memdesc:gab746c6cccbfe8d25a892eb415bcedd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print information about the worker.  <a href="#gab746c6cccbfe8d25a892eb415bcedd97">More...</a><br /></td></tr>
<tr class="separator:gab746c6cccbfe8d25a892eb415bcedd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41aaa5fb8fbd3de50a39b1fda12977cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga41aaa5fb8fbd3de50a39b1fda12977cc">ucp_worker_get_address</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga7d24d2759c1375bf4d2d639e3b701956">ucp_address_t</a> **address_p, size_t *address_length_p)</td></tr>
<tr class="memdesc:ga41aaa5fb8fbd3de50a39b1fda12977cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the address of the worker object.  <a href="#ga41aaa5fb8fbd3de50a39b1fda12977cc">More...</a><br /></td></tr>
<tr class="separator:ga41aaa5fb8fbd3de50a39b1fda12977cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94260829739496267d2c8d86414b863d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga94260829739496267d2c8d86414b863d">ucp_worker_release_address</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga7d24d2759c1375bf4d2d639e3b701956">ucp_address_t</a> *address)</td></tr>
<tr class="memdesc:ga94260829739496267d2c8d86414b863d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release an address of the worker object.  <a href="#ga94260829739496267d2c8d86414b863d">More...</a><br /></td></tr>
<tr class="separator:ga94260829739496267d2c8d86414b863d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga340784a8528d4932916651460dc481c0"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga340784a8528d4932916651460dc481c0">ucp_worker_progress</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker)</td></tr>
<tr class="memdesc:ga340784a8528d4932916651460dc481c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Progress all communications on a specific worker.  <a href="#ga340784a8528d4932916651460dc481c0">More...</a><br /></td></tr>
<tr class="separator:ga340784a8528d4932916651460dc481c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacff2409268fc6620d9a2bca4fa01950"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gaacff2409268fc6620d9a2bca4fa01950">ucp_stream_worker_poll</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#structucp__stream__poll__ep__t">ucp_stream_poll_ep_t</a> *poll_eps, size_t max_eps, unsigned flags)</td></tr>
<tr class="memdesc:gaacff2409268fc6620d9a2bca4fa01950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll for endpoints that are ready to consume streaming data.  <a href="#gaacff2409268fc6620d9a2bca4fa01950">More...</a><br /></td></tr>
<tr class="separator:gaacff2409268fc6620d9a2bca4fa01950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a8943f89a7b49c1f1abc562fb5178ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga7a8943f89a7b49c1f1abc562fb5178ad">ucp_listener_create</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, const <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga2603bc15f79df18099f98b2254afab04">ucp_listener_params_t</a> *params, <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac0496f7102c43cf339cc760b9e5724a2">ucp_listener_h</a> *listener_p)</td></tr>
<tr class="memdesc:ga7a8943f89a7b49c1f1abc562fb5178ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept connections on a local address of the worker object.  <a href="#ga7a8943f89a7b49c1f1abc562fb5178ad">More...</a><br /></td></tr>
<tr class="separator:ga7a8943f89a7b49c1f1abc562fb5178ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae45c609cd659bdd0e205d30627b7af21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gae45c609cd659bdd0e205d30627b7af21">ucp_listener_destroy</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac0496f7102c43cf339cc760b9e5724a2">ucp_listener_h</a> listener)</td></tr>
<tr class="memdesc:gae45c609cd659bdd0e205d30627b7af21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop accepting connections on a local address of the worker object.  <a href="#gae45c609cd659bdd0e205d30627b7af21">More...</a><br /></td></tr>
<tr class="separator:gae45c609cd659bdd0e205d30627b7af21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1620fdbae11ea076875fd6ac644241"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga1f1620fdbae11ea076875fd6ac644241">ucp_listener_reject</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac0496f7102c43cf339cc760b9e5724a2">ucp_listener_h</a> listener, <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga200570bfa7d3a8b50b2a074aaa22d2ed">ucp_conn_request_h</a> conn_request)</td></tr>
<tr class="memdesc:ga1f1620fdbae11ea076875fd6ac644241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reject an incoming connection request.  <a href="#ga1f1620fdbae11ea076875fd6ac644241">More...</a><br /></td></tr>
<tr class="separator:ga1f1620fdbae11ea076875fd6ac644241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05b3b5887475966631c62119d64c6182"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga05b3b5887475966631c62119d64c6182">ucp_worker_fence</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker)</td></tr>
<tr class="memdesc:ga05b3b5887475966631c62119d64c6182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assures ordering between non-blocking operations.  <a href="#ga05b3b5887475966631c62119d64c6182">More...</a><br /></td></tr>
<tr class="separator:ga05b3b5887475966631c62119d64c6182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac461d1034a3313612243a5829b7e3847"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker, unsigned flags, <a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a> cb)</td></tr>
<tr class="memdesc:gac461d1034a3313612243a5829b7e3847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush outstanding AMO and RMA operations on the <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">worker</a>.  <a href="#gac461d1034a3313612243a5829b7e3847">More...</a><br /></td></tr>
<tr class="separator:gac461d1034a3313612243a5829b7e3847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae20b8bc9fbbde208ea266490bde4cbcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gae20b8bc9fbbde208ea266490bde4cbcb">ucp_worker_flush</a> (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> worker)</td></tr>
<tr class="memdesc:gae20b8bc9fbbde208ea266490bde4cbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush outstanding AMO and RMA operations on the <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">worker</a>.  <a href="#gae20b8bc9fbbde208ea266490bde4cbcb">More...</a><br /></td></tr>
<tr class="separator:gae20b8bc9fbbde208ea266490bde4cbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>UCP Worker routines </p>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structucp__worker__attr" id="structucp__worker__attr"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ucp_worker_attr</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The structure defines the attributes which characterize the particular worker. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="af0f34f82bba00221aa22ec54fa5efc0f"></a>uint64_t</td>
<td class="fieldname">
field_mask</td>
<td class="fielddoc">
<p>Mask of valid fields in this structure, using bits from <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gacf03ee299a48c2f9c776516cc82c7194">ucp_worker_attr_field</a>. Fields not specified in this mask will be ignored. Provides ABI compatibility with respect to adding new fields. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="abf2b8b0c74946fbd1791a21369236678"></a><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga40e9f363c389e702ad9920f5d52525ce">ucs_thread_mode_t</a></td>
<td class="fieldname">
thread_mode</td>
<td class="fielddoc">
<p>Thread safe level of the worker. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a6c288e285b8c870ec576f1a939519799"></a>uint32_t</td>
<td class="fieldname">
address_flags</td>
<td class="fielddoc">
<p>Flags indicating requested details of the worker address. If <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ggacf03ee299a48c2f9c776516cc82c7194a9b007ce57d2935817f86b4c4c6aad8c9">UCP_WORKER_ATTR_FIELD_ADDRESS_FLAGS</a> bit is set in the field_mask, this value should be set as well. Possible flags are specified in <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gab1ec638cc4a7498a85017d132492d195">ucp_worker_address_flags_t</a>. </p><dl class="section note"><dt>Note</dt><dd>This is an input attribute. </dd></dl>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a0863e78ee73ef351311c54d95b6c8fa5"></a><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga7d24d2759c1375bf4d2d639e3b701956">ucp_address_t</a> *</td>
<td class="fieldname">
address</td>
<td class="fielddoc">
<p>Worker address, which can be passed to remote instances of the UCP library in order to connect to this worker. The memory for the address handle is allocated by <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gaab678930b792e328eb4f0a17654e5e42">ucp_worker_query()</a> routine, and must be released by using <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga94260829739496267d2c8d86414b863d">ucp_worker_release_address()</a> routine. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a7b0ad8e7e5c8d4c4c4931e769ca0fe6f"></a>size_t</td>
<td class="fieldname">
address_length</td>
<td class="fielddoc">
<p>Size of worker address in bytes. </p>
</td></tr>
</table>

</div>
</div>
<a name="structucp__worker__params" id="structucp__worker__params"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ucp_worker_params</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The structure defines the parameters that are used for the UCP worker tuning during the UCP worker <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga0aec01ed3dad646ca6cd3814b13054b1">creation</a>. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ucp_hello_world_8c-example.html#_a31">ucp_hello_world.c</a>.</dd>
</dl></div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a33863ec848e47f79d2e14181fe2aa921"></a>uint64_t</td>
<td class="fieldname">
field_mask</td>
<td class="fielddoc">
<p>Mask of valid fields in this structure, using bits from <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gadbfc8fd5eaa65351d1617f2f158b80f6">ucp_worker_params_field</a>. Fields not specified in this mask will be ignored. Provides ABI compatibility with respect to adding new fields. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a790642ea681ddd2b0935ad62f70e4ef1"></a><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga40e9f363c389e702ad9920f5d52525ce">ucs_thread_mode_t</a></td>
<td class="fieldname">
thread_mode</td>
<td class="fielddoc">
<p>The parameter thread_mode suggests the thread safety mode which worker and the associated resources should be created with. This is an optional parameter. The default value is UCS_THREAD_MODE_SINGLE and it is used when the value of the parameter is not set. When this parameter along with its corresponding bit in the field_mask - UCP_WORKER_PARAM_FIELD_THREAD_MODE is set, the <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga0aec01ed3dad646ca6cd3814b13054b1">ucp_worker_create</a> attempts to create worker with this thread mode. The thread mode with which worker is created can differ from the suggested mode. The actual thread mode of the worker should be obtained using the query interface <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gaab678930b792e328eb4f0a17654e5e42">ucp_worker_query</a>. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="afc8f70f3ff12f36ea34ad40ff12de61e"></a>ucs_cpu_set_t</td>
<td class="fieldname">
cpu_mask</td>
<td class="fielddoc">
<p>Mask of which CPUs worker resources should preferably be allocated on. This value is optional. If it's not set (along with its corresponding bit in the field_mask - UCP_WORKER_PARAM_FIELD_CPU_MASK), resources are allocated according to system's default policy. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a89b9add865222b57caee81874704ba89"></a>unsigned</td>
<td class="fieldname">
events</td>
<td class="fielddoc">
<p>Mask of events (<a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gae454437b2f4d1bd23dfc8975bbe60c2e">ucp_wakeup_event_t</a>) which are expected on wakeup. This value is optional. If it's not set (along with its corresponding bit in the field_mask - UCP_WORKER_PARAM_FIELD_EVENTS), all types of events will trigger on wakeup. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a2c277d353e134219265887c4f5339159"></a>void *</td>
<td class="fieldname">
user_data</td>
<td class="fielddoc">
<p>User data associated with the current worker. This value is optional. If it's not set (along with its corresponding bit in the field_mask - UCP_WORKER_PARAM_FIELD_USER_DATA), it will default to NULL. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aaeaf0e7ec196ed72ee2b52183f8d1d7d"></a>int</td>
<td class="fieldname">
event_fd</td>
<td class="fielddoc">
<p>External event file descriptor. This value is optional. If <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ggadbfc8fd5eaa65351d1617f2f158b80f6ae743c2d23a0d7b0a9a8c6362a7611139">UCP_WORKER_PARAM_FIELD_EVENT_FD</a> is set in the field_mask, events on the worker will be reported on the provided event file descriptor. In this case, calling <a class="el" href="group___u_c_p___w_a_k_e_u_p.html#gadf849649110fa338fd891548198a578b">ucp_worker_get_efd</a> will result in an error. The provided file descriptor must be capable of aggregating notifications for arbitrary events, for example <code>epoll(7)</code> on Linux systems. <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#a2c277d353e134219265887c4f5339159">user_data</a> will be used as the event user-data on systems which support it. For example, on Linux, it will be placed in <code>epoll_data_t::ptr</code>, when returned from <code>epoll_wait(2)</code>.</p>
<p>Otherwise, events will be reported to the event file descriptor returned from <a class="el" href="group___u_c_p___w_a_k_e_u_p.html#gadf849649110fa338fd891548198a578b">ucp_worker_get_efd()</a>. </p>
</td></tr>
</table>

</div>
</div>
<a name="structucp__listener__params" id="structucp__listener__params"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ucp_listener_params</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure defines parameters for <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga7a8943f89a7b49c1f1abc562fb5178ad">ucp_listener_create</a>, which is used to listen for incoming client/server connections. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="afb01e3b0d3c0a04cef0cde4f849fcc1d"></a>uint64_t</td>
<td class="fieldname">
field_mask</td>
<td class="fielddoc">
<p>Mask of valid fields in this structure, using bits from <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga36d95269fcce844261494cbd4f5e26fc">ucp_listener_params_field</a>. Fields not specified in this mask will be ignored. Provides ABI compatibility with respect to adding new fields. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a88be57709393e7bf27d10d8a5238b544"></a><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga1f31d58cb8b110b03a3df3efc04ab3c0">ucs_sock_addr_t</a></td>
<td class="fieldname">
sockaddr</td>
<td class="fielddoc">
<p>An address in the form of a sockaddr. This field is mandatory for filling (along with its corresponding bit in the field_mask - <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gga36d95269fcce844261494cbd4f5e26fca0eed5ab19654fabc0afceb5b439c6f05">UCP_LISTENER_PARAM_FIELD_SOCK_ADDR</a>). The <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga7a8943f89a7b49c1f1abc562fb5178ad">ucp_listener_create</a> routine will return with an error if sockaddr is not specified. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a17487f0e8e3102519d7b512c77efdb1f"></a><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gad8b65bba266c848ca394ec48da48bc18">ucp_listener_accept_handler_t</a></td>
<td class="fieldname">
accept_handler</td>
<td class="fielddoc">
<p>Handler to endpoint creation in a client-server connection flow. In order for the callback inside this handler to be invoked, the UCP_LISTENER_PARAM_FIELD_ACCEPT_HANDLER needs to be set in the field_mask. </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a0694aacde5fff09dc75e556e8116098a"></a><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga558f048d85d5600f95c2f733ddc6b3e8">ucp_listener_conn_handler_t</a></td>
<td class="fieldname">
conn_handler</td>
<td class="fielddoc">
<p>Handler of an incoming connection request in a client-server connection flow. In order for the callback inside this handler to be invoked, the <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gga36d95269fcce844261494cbd4f5e26fca6f28cd3c96e0ada4fafc63d6f67e48bc">UCP_LISTENER_PARAM_FIELD_CONN_HANDLER</a> needs to be set in the field_mask. </p>
</td></tr>
</table>

</div>
</div>
<a name="structucp__listener__accept__handler" id="structucp__listener__accept__handler"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ucp_listener_accept_handler</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga558f048d85d5600f95c2f733ddc6b3e8">ucp_listener_conn_handler_t</a>. </dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a3017ef77fb807d87b60667df14f6c0b0"></a><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga9a1d61f9a3c1fd97c008dd77ae86c02c">ucp_listener_accept_callback_t</a></td>
<td class="fieldname">
cb</td>
<td class="fielddoc">
<p>Endpoint creation callback </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a05ba12e5d6e6c2b3caef35975644ce85"></a>void *</td>
<td class="fieldname">
arg</td>
<td class="fielddoc">
<p>User defined argument for the callback </p>
</td></tr>
</table>

</div>
</div>
<a name="structucp__listener__conn__handler" id="structucp__listener__conn__handler"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ucp_listener_conn_handler</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This structure is used for handling an incoming connection request on the listener. Setting this type of handler allows creating an endpoint on any other worker and not limited to the worker on which the listener was created. </p><dl class="section note"><dt>Note</dt><dd><ul>
<li>Other than communication progress routines, it is allowed to call all other communication routines from the callback in the struct.</li>
<li>The callback is thread safe with respect to the worker it is invoked on.</li>
<li>It is the user's responsibility to avoid potential dead lock accessing different worker. </li>
</ul>
</dd></dl>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a55ac5ba9e07ca64d55e22730038a4018"></a><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga389a8cfa253f87eb9d8cc7b8d4747c82">ucp_listener_conn_callback_t</a></td>
<td class="fieldname">
cb</td>
<td class="fielddoc">
<p>Connection request callback </p>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae84882c5fbe486b118460662afe395ec"></a>void *</td>
<td class="fieldname">
arg</td>
<td class="fielddoc">
<p>User defined argument for the callback </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga27a9d7a36ee31d7718f6ec2819108d07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#structucp__worker__attr">ucp_worker_attr</a>  <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga27a9d7a36ee31d7718f6ec2819108d07">ucp_worker_attr_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The structure defines the attributes which characterize the particular worker. </p>

</div>
</div>
<a class="anchor" id="ga7aad09f7b71f912abe0b120872a236f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#structucp__worker__params">ucp_worker_params</a>  <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga7aad09f7b71f912abe0b120872a236f2">ucp_worker_params_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The structure defines the parameters that are used for the UCP worker tuning during the UCP worker <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga0aec01ed3dad646ca6cd3814b13054b1">creation</a>. </p>

</div>
</div>
<a class="anchor" id="ga2603bc15f79df18099f98b2254afab04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#structucp__listener__params">ucp_listener_params</a>  <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga2603bc15f79df18099f98b2254afab04">ucp_listener_params_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure defines parameters for <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga7a8943f89a7b49c1f1abc562fb5178ad">ucp_listener_create</a>, which is used to listen for incoming client/server connections. </p>

</div>
</div>
<a class="anchor" id="gad8b65bba266c848ca394ec48da48bc18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#structucp__listener__accept__handler">ucp_listener_accept_handler</a>  <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gad8b65bba266c848ca394ec48da48bc18">ucp_listener_accept_handler_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga558f048d85d5600f95c2f733ddc6b3e8">ucp_listener_conn_handler_t</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d24d2759c1375bf4d2d639e3b701956"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ucp_address <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga7d24d2759c1375bf4d2d639e3b701956">ucp_address_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The address handle is an opaque object that is used as an identifier for a <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">worker</a> instance. </p>

</div>
</div>
<a class="anchor" id="gac0496f7102c43cf339cc760b9e5724a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ucp_listener* <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac0496f7102c43cf339cc760b9e5724a2">ucp_listener_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The listener handle is an opaque object that is used for listening on a specific address and accepting connections from clients. </p>

</div>
</div>
<a class="anchor" id="ga5fd52efba31d20fc52055bb19270729f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ucp_worker* <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UCP worker is an opaque object representing the communication context. The worker represents an instance of a local communication resource and progress engine associated with it. Progress engine is a construct that is responsible for asynchronous and independent progress of communication directives. The progress engine could be implement in hardware or software. The worker object abstract an instance of network resources such as a host channel adapter port, network interface, or multiple resources such as multiple network interfaces or communication ports. It could also represent virtual communication resources that are defined across multiple devices. Although the worker can represent multiple network resources, it is associated with a single <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">UCX application context</a>. All communication functions require a context to perform the operation on the dedicated hardware resource(s) and an <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">endpoint</a> to address the destination.</p>
<dl class="section note"><dt>Note</dt><dd>Worker are parallel "threading points" that an upper layer may use to optimize concurrent communications. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9a1d61f9a3c1fd97c008dd77ae86c02c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_listener_accept_callback_t) (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga9bea4e4174ea25f44285d8e7a9fb7adf">ucp_ep_h</a> ep, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked on the server side upon creating a connection to a remote client. The user can pass an argument to this callback. The user is responsible for releasing the <em>ep</em> handle using the <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#gac63b3fe87c001dd965ca42943ea04bb1">ucp_ep_destroy()</a> routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Handle to a newly created endpoint which is connected to the remote peer which has initiated the connection. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>User's argument for the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga389a8cfa253f87eb9d8cc7b8d4747c82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* ucp_listener_conn_callback_t) (<a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga200570bfa7d3a8b50b2a074aaa22d2ed">ucp_conn_request_h</a> conn_request, void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This callback routine is invoked on the server side to handle incoming connections from remote clients. The user can pass an argument to this callback. The <em>conn_request</em> handle has to be released, either by <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga6cc5ffb2ba1b0ccd510848de0a779f7b">ucp_ep_create</a> or <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga1f1620fdbae11ea076875fd6ac644241">ucp_listener_reject</a> routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn_request</td><td>Connection request handle. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>User's argument for the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga558f048d85d5600f95c2f733ddc6b3e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#structucp__listener__conn__handler">ucp_listener_conn_handler</a>  <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga558f048d85d5600f95c2f733ddc6b3e8">ucp_listener_conn_handler_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This structure is used for handling an incoming connection request on the listener. Setting this type of handler allows creating an endpoint on any other worker and not limited to the worker on which the listener was created. </p><dl class="section note"><dt>Note</dt><dd><ul>
<li>Other than communication progress routines, it is allowed to call all other communication routines from the callback in the struct.</li>
<li>The callback is thread safe with respect to the worker it is invoked on.</li>
<li>It is the user's responsibility to avoid potential dead lock accessing different worker. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae454437b2f4d1bd23dfc8975bbe60c2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga66be8946dcd33051d40ceca65ba28e22">ucp_wakeup_event_types</a>  <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gae454437b2f4d1bd23dfc8975bbe60c2e">ucp_wakeup_event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration allows specifying which events are expected on wakeup. Empty events are possible for any type of event except for <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gga66be8946dcd33051d40ceca65ba28e22ad70899effbabed3294c35b9b0f2a747b">UCP_WAKEUP_TX</a> and <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gga66be8946dcd33051d40ceca65ba28e22a182a353c533fc335e638e41fdaf7c6b5">UCP_WAKEUP_RX</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Send completions are reported by POLLIN-like events (see poll man page). Since outgoing operations can be initiated at any time, UCP does not generate POLLOUT-like events, although it must be noted that outgoing operations may be queued depending upon resource availability. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gadbfc8fd5eaa65351d1617f2f158b80f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gadbfc8fd5eaa65351d1617f2f158b80f6">ucp_worker_params_field</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration allows specifying which fields in <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga7aad09f7b71f912abe0b120872a236f2">ucp_worker_params_t</a> are present. It is used for the enablement of backward compatibility support. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggadbfc8fd5eaa65351d1617f2f158b80f6a651598f7340d42cafb0876d918c83ec8"></a>UCP_WORKER_PARAM_FIELD_THREAD_MODE&#160;</td><td class="fielddoc">
<p>UCP thread mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadbfc8fd5eaa65351d1617f2f158b80f6a0ba499461804b26850d6a530609e228d"></a>UCP_WORKER_PARAM_FIELD_CPU_MASK&#160;</td><td class="fielddoc">
<p>Worker's CPU bitmap </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadbfc8fd5eaa65351d1617f2f158b80f6ac756667325d053bd1cc11cccf853b0c9"></a>UCP_WORKER_PARAM_FIELD_EVENTS&#160;</td><td class="fielddoc">
<p>Worker's events bitmap </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadbfc8fd5eaa65351d1617f2f158b80f6a1243d403aeceab36eee6d9cb985e8eb0"></a>UCP_WORKER_PARAM_FIELD_USER_DATA&#160;</td><td class="fielddoc">
<p>User data </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggadbfc8fd5eaa65351d1617f2f158b80f6ae743c2d23a0d7b0a9a8c6362a7611139"></a>UCP_WORKER_PARAM_FIELD_EVENT_FD&#160;</td><td class="fielddoc">
<p>External event file descriptor </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga36d95269fcce844261494cbd4f5e26fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga36d95269fcce844261494cbd4f5e26fc">ucp_listener_params_field</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration allows specifying which fields in <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga2603bc15f79df18099f98b2254afab04">ucp_listener_params_t</a> are present. It is used for the enablement of backward compatibility support. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga36d95269fcce844261494cbd4f5e26fca0eed5ab19654fabc0afceb5b439c6f05"></a>UCP_LISTENER_PARAM_FIELD_SOCK_ADDR&#160;</td><td class="fielddoc">
<p>Sock address and length. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga36d95269fcce844261494cbd4f5e26fca3cdf187536d998c115377f8de396ac66"></a>UCP_LISTENER_PARAM_FIELD_ACCEPT_HANDLER&#160;</td><td class="fielddoc">
<p>User's callback and argument for handling the creation of an endpoint.User's callback and argument for handling the incoming connection request. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga36d95269fcce844261494cbd4f5e26fca6f28cd3c96e0ada4fafc63d6f67e48bc"></a>UCP_LISTENER_PARAM_FIELD_CONN_HANDLER&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gab1ec638cc4a7498a85017d132492d195"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gab1ec638cc4a7498a85017d132492d195">ucp_worker_address_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration list describes possible UCP worker address flags, indicating what needs to be included to the worker address returned by <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gaab678930b792e328eb4f0a17654e5e42">ucp_worker_query()</a> routine. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggab1ec638cc4a7498a85017d132492d195af9fe9ee3edc7fe21c889437941bb4117"></a>UCP_WORKER_ADDRESS_FLAG_NET_ONLY&#160;</td><td class="fielddoc">
<p>Pack addresses of network devices only. Using such shortened addresses for the remote node peers will reduce the amount of wireup data being exchanged during connection establishment phase. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gacf03ee299a48c2f9c776516cc82c7194"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gacf03ee299a48c2f9c776516cc82c7194">ucp_worker_attr_field</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration allows specifying which fields in <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga27a9d7a36ee31d7718f6ec2819108d07">ucp_worker_attr_t</a> are present. It is used for the enablement of backward compatibility support. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggacf03ee299a48c2f9c776516cc82c7194a6d3178929ef9e6570999384991fbd42d"></a>UCP_WORKER_ATTR_FIELD_THREAD_MODE&#160;</td><td class="fielddoc">
<p>UCP thread mode </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggacf03ee299a48c2f9c776516cc82c7194a0dde53e12c0ab222ddcf2a52984fddd2"></a>UCP_WORKER_ATTR_FIELD_ADDRESS&#160;</td><td class="fielddoc">
<p>UCP address </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggacf03ee299a48c2f9c776516cc82c7194a9b007ce57d2935817f86b4c4c6aad8c9"></a>UCP_WORKER_ATTR_FIELD_ADDRESS_FLAGS&#160;</td><td class="fielddoc">
<p>UCP address flags </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga66be8946dcd33051d40ceca65ba28e22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga66be8946dcd33051d40ceca65ba28e22">ucp_wakeup_event_types</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enumeration allows specifying which events are expected on wakeup. Empty events are possible for any type of event except for <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gga66be8946dcd33051d40ceca65ba28e22ad70899effbabed3294c35b9b0f2a747b">UCP_WAKEUP_TX</a> and <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gga66be8946dcd33051d40ceca65ba28e22a182a353c533fc335e638e41fdaf7c6b5">UCP_WAKEUP_RX</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Send completions are reported by POLLIN-like events (see poll man page). Since outgoing operations can be initiated at any time, UCP does not generate POLLOUT-like events, although it must be noted that outgoing operations may be queued depending upon resource availability. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga66be8946dcd33051d40ceca65ba28e22a80fc6d63077023d905d9f3adfb37c50a"></a>UCP_WAKEUP_RMA&#160;</td><td class="fielddoc">
<p>Remote memory access send completion </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga66be8946dcd33051d40ceca65ba28e22a1f8891a39fe63593947811936a9af8f7"></a>UCP_WAKEUP_AMO&#160;</td><td class="fielddoc">
<p>Atomic operation send completion </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga66be8946dcd33051d40ceca65ba28e22a136d0a608b0dcceb731d3022f1cb0e91"></a>UCP_WAKEUP_TAG_SEND&#160;</td><td class="fielddoc">
<p>Tag send completion </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga66be8946dcd33051d40ceca65ba28e22a15bd79b8acc9815513dccf43fc350435"></a>UCP_WAKEUP_TAG_RECV&#160;</td><td class="fielddoc">
<p>Tag receive completion </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga66be8946dcd33051d40ceca65ba28e22ad70899effbabed3294c35b9b0f2a747b"></a>UCP_WAKEUP_TX&#160;</td><td class="fielddoc">
<p>This event type will generate an event on completion of any outgoing operation (complete or partial, according to the underlying protocol) for any type of transfer (send, atomic, or RMA). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga66be8946dcd33051d40ceca65ba28e22a182a353c533fc335e638e41fdaf7c6b5"></a>UCP_WAKEUP_RX&#160;</td><td class="fielddoc">
<p>This event type will generate an event on completion of any receive operation (complete or partial, according to the underlying protocol). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga66be8946dcd33051d40ceca65ba28e22a474ecc6ca013d28f71ade5d85aafd1c8"></a>UCP_WAKEUP_EDGE&#160;</td><td class="fielddoc">
<p>Use edge-triggered wakeup. The event file descriptor will be signaled only for new events, rather than existing ones. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0aec01ed3dad646ca6cd3814b13054b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_worker_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">ucp_context_h</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga7aad09f7b71f912abe0b120872a236f2">ucp_worker_params_t</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a> *&#160;</td>
          <td class="paramname"><em>worker_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine allocates and initializes a <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">worker</a> object. Each worker is associated with one and only one <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">application</a> context. In the same time, an application context can create multiple <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">workers</a> in order to enable concurrent access to communication resources. For example, application can allocate a dedicated worker for each application thread, where every worker can be progressed independently of others.</p>
<dl class="section note"><dt>Note</dt><dd>The worker object is allocated within context of the calling thread</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Handle to <a class="el" href="group___u_c_p___c_o_n_t_e_x_t.html#ga0e40ddc46f0bbe868a13f6ab1b674f76">UCP application context</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>User defined <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga7aad09f7b71f912abe0b120872a236f2">ucp_worker_params_t</a> configurations for the <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">UCP worker</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">worker_p</td><td>A pointer to the worker object allocated by the UCP library</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ucp_hello_world_8c-example.html#a49">ucp_hello_world.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga6b6c5bf97d16e7fc4b7c815875e92676"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_worker_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine releases the resources associated with a <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">UCP worker</a>.</p>
<dl class="section warning"><dt>Warning</dt><dd>Once the UCP worker destroy the worker handle cannot be used with any UCP routine.</dd></dl>
<p>The destroy process releases and shuts down all resources associated with the <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">worker</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>Worker object to destroy. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ucp_hello_world_8c-example.html#a52">ucp_hello_world.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaab678930b792e328eb4f0a17654e5e42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_worker_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga27a9d7a36ee31d7718f6ec2819108d07">ucp_worker_attr_t</a> *&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine fetches information about the worker.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>Worker object to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">attr</td><td>Filled with attributes of worker.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab746c6cccbfe8d25a892eb415bcedd97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_worker_print_info </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine prints information about the protocols being used, thresholds, UCT transport methods, and other useful information associated with the worker.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>Worker object to print information for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>Output stream to print the information to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga41aaa5fb8fbd3de50a39b1fda12977cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_worker_get_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga7d24d2759c1375bf4d2d639e3b701956">ucp_address_t</a> **&#160;</td>
          <td class="paramname"><em>address_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>address_length_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine returns the address of the worker object. This address can be passed to remote instances of the UCP library in order to connect to this worker. The memory for the address handle is allocated by this function, and must be released by using <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga94260829739496267d2c8d86414b863d">ucp_worker_release_address()</a> routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>Worker object whose address to return. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">address_p</td><td>A pointer to the worker address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">address_length_p</td><td>The size in bytes of the address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ucp_hello_world_8c-example.html#a50">ucp_hello_world.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga94260829739496267d2c8d86414b863d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_worker_release_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga7d24d2759c1375bf4d2d639e3b701956">ucp_address_t</a> *&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine release an <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga7d24d2759c1375bf4d2d639e3b701956">address handle</a> associated within the <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">worker</a> object.</p>
<dl class="section warning"><dt>Warning</dt><dd>Once the address released the address handle cannot be used with any UCP routine.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>Worker object that is associated with the address object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>Address to release; the address object has to be allocated using <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga41aaa5fb8fbd3de50a39b1fda12977cc">ucp_worker_get_address()</a> routine.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ucp_hello_world_8c-example.html#a51">ucp_hello_world.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ga340784a8528d4932916651460dc481c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ucp_worker_progress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine explicitly progresses all communication operations on a worker.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Typically, request wait and test routines call <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga340784a8528d4932916651460dc481c0">this routine</a> to progress any outstanding operations. </li>
<li>Transport layers, implementing asynchronous progress using threads, require callbacks and other user code to be thread safe. </li>
<li>The state of communication can be advanced (progressed) by blocking routines. Nevertheless, the non-blocking routines can not be used for communication progress.</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>Worker to progress.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Non-zero if any communication was progressed, zero otherwise. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="ucp_hello_world_8c-example.html#a3">ucp_hello_world.c</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="gaacff2409268fc6620d9a2bca4fa01950"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t ucp_stream_worker_poll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#structucp__stream__poll__ep__t">ucp_stream_poll_ep_t</a> *&#160;</td>
          <td class="paramname"><em>poll_eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This non-blocking routine returns endpoints on a worker which are ready to consume streaming data. The ready endpoints are placed in <em>poll_eps</em> array, and the function return value indicates how many are there.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>Worker to poll. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">poll_eps</td><td>Pointer to array of endpoints, should be allocated by user. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_eps</td><td>Maximal number of endpoints which should be filled in <em>poll_eps</em>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Reserved for future use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Negative value indicates an error according to <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a>. On success, non-negative value (less or equal <em>max_eps</em>) indicates actual number of endpoints filled in <em>poll_eps</em> array. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a8943f89a7b49c1f1abc562fb5178ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_listener_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga2603bc15f79df18099f98b2254afab04">ucp_listener_params_t</a> *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac0496f7102c43cf339cc760b9e5724a2">ucp_listener_h</a> *&#160;</td>
          <td class="paramname"><em>listener_p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine binds the worker object to a <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga1f31d58cb8b110b03a3df3efc04ab3c0">ucs_sock_addr_t</a> sockaddr which is set by the user. The worker will listen to incoming connection requests and upon receiving such a request from the remote peer, an endpoint to it will be created. The user's call-back will be invoked once the endpoint is created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>Worker object that is associated with the params object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>User defined <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga2603bc15f79df18099f98b2254afab04">ucp_listener_params_t</a> configurations for the <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac0496f7102c43cf339cc760b9e5724a2">ucp_listener_h</a>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">listener_p</td><td>A handle to the created listener, can be released by calling <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gae45c609cd659bdd0e205d30627b7af21">ucp_listener_destroy</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae45c609cd659bdd0e205d30627b7af21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucp_listener_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac0496f7102c43cf339cc760b9e5724a2">ucp_listener_h</a>&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine unbinds the worker from the given handle and stops listening for incoming connection requests on it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">listener</td><td>A handle to the listener to stop listening on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1f1620fdbae11ea076875fd6ac644241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_listener_reject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac0496f7102c43cf339cc760b9e5724a2">ucp_listener_h</a>&#160;</td>
          <td class="paramname"><em>listener</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#ga200570bfa7d3a8b50b2a074aaa22d2ed">ucp_conn_request_h</a>&#160;</td>
          <td class="paramname"><em>conn_request</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reject the incoming connection request and release associated resources. If the remote initiator endpoint has set an <a class="el" href="group___u_c_p___e_n_d_p_o_i_n_t.html#aaf329de9e2b45311099cee8c9df43a20">ucp_ep_params_t::err_handler</a>, it will be invoked with status <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gga88ca72d7294772e7d2edb70a2df15558a7ebfa416cd741e37ec1a0371feaaa10a">UCS_ERR_REJECTED</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">listener</td><td>Handle to the listener on which the connection request was received. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">conn_request</td><td>Handle to the connection request to reject.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga05b3b5887475966631c62119d64c6182"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_worker_fence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine ensures ordering of non-blocking communication operations on the <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">UCP worker</a>. Communication operations issued on the <em>worker</em> prior to this call are guaranteed to be completed before any subsequent communication operations to the same <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">worker</a> which follow the call to <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga05b3b5887475966631c62119d64c6182">fence</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The primary difference between <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga05b3b5887475966631c62119d64c6182">ucp_worker_fence()</a> and the <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb()</a> is the fact the fence routine does not guarantee completion of the operations on the call return but only ensures the order between communication operations. The <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">flush</a> operation on return guarantees that all operations are completed and corresponding memory regions were updated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gac461d1034a3313612243a5829b7e3847"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#gaf4381d25f2fb0cf02f996f3e0729ed62">ucs_status_ptr_t</a> ucp_worker_flush_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_c_p___c_o_m_m.html#gaad905bbbff95166a1e9b0e9743feb677">ucp_send_callback_t</a>&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This routine flushes all outstanding AMO and RMA communications on the <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">worker</a>. All the AMO and RMA operations issued on the <em>worker</em> prior to this call are completed both at the origin and at the target when this call returns.</p>
<dl class="section note"><dt>Note</dt><dd>For description of the differences between <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">flush</a> and <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga05b3b5887475966631c62119d64c6182">fence</a> operations please see <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga05b3b5887475966631c62119d64c6182">ucp_worker_fence()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Flags for flush operation. Reserved for future use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>Callback which will be called when the flush operation completes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UCS_OK - The flush operation was completed immediately. </dd>
<dd>
UCS_PTR_IS_ERR(_ptr) - The flush operation failed. </dd>
<dd>
otherwise - Flush operation was scheduled and can be completed in any point in time. The request handle is returned to the application in order to track progress. The application is responsible for releasing the handle using <a class="el" href="group___u_c_p___c_o_m_m.html#ga0e8e46f5953d464382b21edef3ec9994">ucp_request_free()</a> routine. </dd></dl>

</div>
</div>
<a class="anchor" id="gae20b8bc9fbbde208ea266490bde4cbcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> ucp_worker_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">ucp_worker_h</a>&#160;</td>
          <td class="paramname"><em>worker</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb</a>. The following example implements the same functionality using <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gac461d1034a3313612243a5829b7e3847">ucp_worker_flush_nb</a> : <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;ucs_status_t worker_flush(ucp_worker_h worker)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;{</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    void *request = ucp_worker_flush_nb(worker);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    if (request == NULL) {</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;        return UCS_OK;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    } else if (UCS_PTR_IS_ERR(request)) {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;        return UCS_PTR_STATUS(request);</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    } else {</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;        ucs_status_t status;</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;        do {</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;            ucp_worker_progress(worker);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;            status = ucp_request_check_status(request);</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        } while (status == UCS_INPROGRESS);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        ucp_request_release(request);</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        return status;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    }</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;}</div>
</div><!-- fragment --></dd></dl>
<p>This routine flushes all outstanding AMO and RMA communications on the <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga5fd52efba31d20fc52055bb19270729f">worker</a>. All the AMO and RMA operations issued on the <em>worker</em> prior to this call are completed both at the origin and at the target when this call returns.</p>
<dl class="section note"><dt>Note</dt><dd>For description of the differences between <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#gae20b8bc9fbbde208ea266490bde4cbcb">flush</a> and <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga05b3b5887475966631c62119d64c6182">fence</a> operations please see <a class="el" href="group___u_c_p___w_o_r_k_e_r.html#ga05b3b5887475966631c62119d64c6182">ucp_worker_fence()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">worker</td><td>UCP worker.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Error code as defined by <a class="el" href="group___u_c_s___r_e_s_o_u_r_c_e.html#ga88ca72d7294772e7d2edb70a2df15558">ucs_status_t</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Jul 18 2019 11:16:37 for UCX by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
